----table to capture IO stats
Create table Peak_iops_measurement 
(capture_timestamp date,
total_read_io number,
total_write_io number,
total_io number,
total_read_bytes number,
total_write_bytes number,
total_bytes number);

create synonym peak_IOPS_TABLE for PEAK_IOPS_MEASUREMENT;
grant select on PEAK_IOPS_MEASUREMENT to PUBLIC;

-----------script to run for (run_duration=60Min) with  (capture_gap=5scd) to collect IO stats in peak_iops_m table

grant execute on dbms_lock to kh85124;
grant select on v_$sysstat to kh85124;
--v$sysstat for 12c

create or replace procedure calculate_IOPS(h IN number) is 
   run_duration number :=h*3600;
   capture_gap number :=5;
   loop_count number :=run_duration/capture_gap;
   rdio number ;
   wtio number;
   prev_rdio number :=0;
   prev_wtio number :=0;
   rdbt number;
   wtbt number;
   prev_rdbt number;
   prev_wtbt number;
   
BEGIN 
 FOR i in 1..loop_count LOOP
   SELECT SUM(value) INTO rdio from v$sysstat 
   WHERE name='physical read total IO requests';
   SELECT SUM(value) INTO wtio from v$sysstat 
   WHERE name='physical write total IO requests';
   SELECT SUM(value* 0.000008) INTO rdbt from v$sysstat 
   WHERE name='physical read total bytes';
   SELECT SUM(value* 0.000008) INTO wtbt from v$sysstat 
   WHERE name='physical write total bytes';
   IF i> 1 THEN 
             insert into peak_iops_measurement(capture_timestamp,total_read_io,total_write_io,total_io,total_read_bytes,total_write_bytes,total_bytes)
             VALUES (
             sysdate,
             (rdio-prev_rdio)/5,
             (wtio-prev_wtio)/5,
             ((rdio-prev_rdio)/5)+((wtio-prev_wtio))/5,
             (rdbt-prev_rdbt)/5,
             (wtbt-prev_wtbt)/5,
             ((rdbt-prev_rdbt)/5)+((wtbt-prev_wtbt))/5);
   END IF;
         prev_rdio:=rdio;
         prev_wtio:=wtio;
         prev_rdbt:=rdbt;
         prev_wtbt:=wtbt;
         DBMS_LOCK.SLEEP(capture_gap);
 END LOOP;
 COMMIT;
 EXCEPTION
 WHEN OTHERS THEN 
     ROLLBACK;
     
 END;
 / 
 
 
 ------------FIND peack IOPS used by the database seek largest value for TOTAL_IO
 SELECT total_io PEAK_IOPS,total_bytes PEAK_MB,round((total_read_io/total_io)*100,2) "read_%",round((total_write_io/total_io)*100,2) "write%"  FROM PEAK_IOPS_MEASUREMENT where total_io =(select max(total_io) from PEAK_IOPS_MEASUREMENT) ;
 
 
 HMR 
 kh85124@PRD1>  SELECT round(total_io,2) PEAK_IOPS,round(total_bytes,2) PEAK_MB,round((total_read_io/total_io)*100,2) "read_%",round((total_write_io/total_io)*100,2) "write%" ,b.MAX_MBS FROM PEAK_IOPS_MEASUREMENT,(select round(max(total_bytes),2) max_mbs from peak_iops_table)b where total_io =(select max(total_io) from PEAK_IOPS_MEASUREMENT) ;

 PEAK_IOPS    PEAK_MB
---------- ----------
    3323.6 981.929984
    
 PEAK_IOPS    PEAK_MB     read_%     write%
---------- ---------- ---------- ----------
    3323.6  219.89      96.56       3.44
    
 
PEAK_IOPS    PEAK_MB     read_%     write%
--------- ---------- ---------- ----------
   3323.6 219.892941      96.56       3.44   
   
Vendredi 08/05
 PEAK_IOPS    PEAK_MB     read_%     write%    MAX_MBS   
---------- ---------- ---------- ---------- ----------    
    3323.6     219.89      96.56       3.44     981.93 
 
 Janvier 23 2017
 PEAK_IOPS    PEAK_MB     read_%     write%    MAX_MBS   
 --------- ---------- ---------- ---------- ----------      
    3702.4    3438.11      98.84       1.16    3438.11
St jerome:

kh85124@PRD1> SELECT MAX(total_io) PEAK_IOPS ,max(total_bytes) PEAK_MB FROM PEAK_IOPS_MEASUREMENT;

 PEAK_IOPS    PEAK_MB
---------- ----------
    1069.8 771.303014

 PEAK_IOPS    PEAK_MB     read_%     write%
---------- ---------- ---------- ----------
    1069.8  104.57088      83.66      16.34
 
 PEAK_IOPS    PEAK_MB     read_%     write%
---------- ---------- ---------- ----------
    1069.8  104.57088      83.66      16.34 

Vendredi 08/05

 PEAK_IOPS    PEAK_MB     read_%     write%    MAX_MBS
---------- ---------- ---------- ---------- -------------------
    3883.4     254.27      99.77        .23      771.3

    
        
 
 
 
 begin
    dbms_scheduler.create_job(job_name        => 'PEAK_IOPS_MEASUREMENT_JOB',
                              job_type        => 'PLSQL_BLOCK',
                              job_action      => 'BEGIN calculate_IOPS(4); END;',
                              start_date      => systimestamp,
                              end_date        => sysdate+7,
                              repeat_interval => 'freq=daily;byday=mon,tue,wed,thu,fri; byhour=8; byminute=30; bysecond=0;',
                              enabled         => true,
                              auto_drop       => false,
                              comments        => 'this job collects IOPS for 4 hours every morining.');
end;
/
 
 BEGIN
  DBMS_SCHEDULER.SET_ATTRIBUTE (
   'mytestjob', 'logging_level', DBMS_SCHEDULER.LOGGING_FULL);
END;
/

DBMS_SCHEDULER.CREATE_PROGRAM                                              DBMS_scheduler.define_program_argument(        
    (                                                                         program_name => 'PEAK_IOPS_MEASUREMENT'     
      program_name         => 'PEAK_IOPS_MEASUREMENT'                       , argument_position => 1                      
     ,program_type         => 'STORED_PROCEDURE'                            , argument_type => 'NUMBER'   --'VARCHAR2'    
     ,program_action       => 'calculate_IOPS'                              , default_value => '1'        --'STARTING'                 
     ,number_of_arguments  => 1                                           );                                              
     ,enabled              => FALSE
     ,comments             => NULL
    );


 DBMS_scheduler.set_attribute(
      name => 'PEAK_IOPS_MEASUREMENT'
    , attribute => 'number_of_arguments'
    , value => 1);
    
    
 DBMS_scheduler.create_job(                                 OR                DBMS_scheduler.set_job_argument_value(
    job_name => 'PEAK_IOPS_MEASUREMENT_JOB'                                   job_name => 'PEAK_IOPS_MEASUREMENT_JOB'     
    , program_name => 'PEAK_IOPS_MEASUREMENT'                                 , argument_position => 1            
    ,number_of_arguments=> 1                                                  , argument_value => '1'         --'STARTING'   
    );                                                                        );                      


SQL> select job_name, enabled,state,NEXT_RUN_Date from DBA_SCHEDULER_JOBS WHERE job_name = ‘PEAK_IOPS_MEASUREMENT_JOB’;
JOB_NAME                       ENABL STATE           NEXT_RUN_DATE
------------------------------ ----- --------------- ------------------------------------
PEAK_IOPS_MEASUREMENT_JOB      TRUE  SCHEDULED       08-SEP-16 09.40.00.000000 AM -04:00

select  JOB_NAME ,LOG_DATE, STATUS, OPERATION,ADDITIONAL_INFO from dba_scheduler_job_log where joB_name like 'PEAK_IOPS%' order by 2;
JOB_NAME                  LOG_DATE                                 STATUS     OPERATION                   ADDITIONAL_INFO
------------------------- ---------------------------------------- ---------- ------------------------------ -----------------------------
PEAK_IOPS_MEASUREMENT_JOB 05-APR-16 12.00.51.090696 PM -04:00      SUCCEEDED  RUN
PEAK_IOPS_MEASUREMENT_JOB 06-APR-16 12.00.47.833068 PM -04:00      SUCCEEDED  RUN
PEAK_IOPS_MEASUREMENT_JOB 07-APR-16 12.00.48.101854 PM -04:00      SUCCEEDED  RUN
PEAK_IOPS_MEASUREMENT_JOB 08-APR-16 12.00.48.357638 PM -04:00      SUCCEEDED  RUN
PEAK_IOPS_MEASUREMENT_JOB 11-APR-16 12.00.42.999953 PM -04:00      SUCCEEDED  RUN
PEAK_IOPS_MEASUREMENT_JOB 11-APR-16 12.00.43.013461 PM -04:00                 COMPLETED                   REASON="End time reached"
st_jérôme

JOB_NAME                  LOG_DATE                            STATUS               OPERATION              ADDITIONAL_INFO
------------------------- ----------------------------------- -------------------- ------------------------------ ----------------------------
PEAK_IOPS_MEASUREMENT_JOB 16-04-05 12:00:46,702000 -04:00     SUCCEEDED            RUN
PEAK_IOPS_MEASUREMENT_JOB 16-04-06 12:00:46,712000 -04:00     SUCCEEDED            RUN
PEAK_IOPS_MEASUREMENT_JOB 16-04-07 12:00:46,044000 -04:00     SUCCEEDED            RUN
PEAK_IOPS_MEASUREMENT_JOB 16-04-08 12:00:51,313000 -04:00     SUCCEEDED            RUN
PEAK_IOPS_MEASUREMENT_JOB 16-04-11 12:00:46,915000 -04:00     SUCCEEDED            RUN
PEAK_IOPS_MEASUREMENT_JOB 16-04-11 12:00:46,931000 -04:00                          COMPLETED              REASON="End time reached"

 
 ---------------add 10 additional percent overhead
 
 RAID IO Penalty write IOPS 15K disk
 ---- ---------- -------------------
 -0        0         175
 -10       2         85
 -5        4         40


RAID 10 IOPS FORMULA:
 (total IOPS* %READ)+((TOTAL_IOPS* %WRITE) xRAID penalty)

Disk IOPS = (Read % * Required IOPS) +
                (Write % * RAID10 write penalty * Required IOPS)
 
RAID 5 IOPS FORMULA:  (4+1 Groups)
 (total IOPS* %READ)+((TOTAL_IOPS* %WRITE) xRAID penalty)

Disk IOPS = (Read % * Required IOPS) +
                (Write % * RAID5 write penalty * Required IOPS)
 
 146GB 4GbFC 15k RPM, 140 IOPS, $1256
300GB 4GbFC 10k RPM, 120 IOPS, $1348
1TB 4Gb SATA II 7.2k RPM, 80 IOPS, $2088

146GB, RAID 5 (4+1): $11.91K/TB
300GB, RAID 5 (4+1): $6.35K/TB
1TB, RAID 5 (4+1): $2.87K/TB
146GB, RAID 10 (4+1): $19.01K/TB
300GB, RAID 10: $10.15K/TB
1TB, RAID 10: $4.59K/TB

 ======================================================
I/O Calibration with the Oracle Orion Calibration Tool
=======================================================
  Orion predicting the performance of an Oracle database without having to install Oracle or create a database.designed for simulating Oracle database I/O workloads using the same I/O software stack as Oracle
  
  **\\CAUTION//** 
  Even if the slightest amount of write operations are planned, it's best to make sure that the mount points are either completely empty or contain no files of significance!!!!!!! :
    create file mytest.lun
     \\.\C:
     \\.\D:
       
Begin test
-------------    
 


 
 ./Orion -run normal -testname IOPS_test -num_disks 2 -verbose

./orion -run oltp  -testname IOPS_test -num_disks 2 -verbose  not available


./orion -run advanced -num_large 0 -size_small 8 -type rand -simulate concat -write 0 -duration 60 -matrix row


To evaluate storage for an OLTP database:

-run oltp
To evaluate storage for a data warehouse:

-run dss
For a basic set of data:

-run normal
To understand your storage performance with read-only, small and large random I/O workload:

$ orion -run simple 
To understand your storage performance with a mixed small and large random I/O workload:

$ orion -run normal 
To generate combinations of 32KB and 1MB reads to random locations:

$ orion -run advanced -size_small 32 \
-size_large 1024 -type rand -matrix detailed
To generate multiple sequential 1 MB write streams, simulating 1 MB RAID-0 stripes:

$ orion -run advanced -simulate raid0 \
-stripe 1024 -write 100 -type seq -matrix col -num_small 0
To generate combinations of 32 KB and 1 MB reads to random locations:

-run advanced -size_small 32 -size_large 1024 -type rand -matrix detailed
To generate multiple sequential 1 MB write streams, simulating RAID0 striping:

-run advanced -simulate raid0 -write 100 -type seq -matrix col -num_small 0
    
    
======================
    CALIBRATE_IO   > +11g
======================


- DBMS_RESOURCE_MANAGER package drives some I/O to the database files to test the throughput and much more metrics.To run I/O calibration and assess the I/O capability of the storage subsystem used by Oracle Database,
  use the DBMS_RESOURCE_MANAGER.CALIBRATE_IO procedure:
  This procedure issues an I/O intensive read-only workload, made up of one megabyte of random of I/Os, to the database files to determine the maximum IOPS (I/O requests per second) and MBPS (megabytes of I/O per second) 
  that can be sustained by the storage subsystem.
Additionally, only one calibration can be performed on a database instance at a time.

PREREQUISIT init paramater:
--------------------------- 
Disk_asynch_io = true
filesystemio_options = asynch
SQL> ALTER SYSTEM SET FILESYSTEMIO_OPTIONS=SETALL SCOPE=SPFILE; =>  RESTART DB 

SQL> SELECT NAME,ASYNCH_IO 
     FROM   V$DATAFILE F,V$IOSTAT_FILE I
     WHERE  F.FILE#=I.FILE_NO AND    FILETYPE_NAME='Data File';

NAME                                               ASYNCH_IO
-------------------------------------------------- ---------
D:\ORACLE\ORADATA\MCRORAT03\SYSTEM01.DBF           ASYNC_ON
D:\ORACLE\ORADATA\MCRORAT03\DATA02.ORA             ASYNC_ON
D:\ORACLE\ORADATA\MCRORAT03\SYSAUX01.DBF           ASYNC_ON
D:\ORACLE\ORADATA\MCRORAT03\INDEX01.ORA            ASYNC_ON
D:\ORACLE\ORADATA\MCRORAT03\UNDOTBS01.DBF          ASYNC_ON
D:\ORACLE\ORADATA\MCRORAT03\USERS01.DBF            ASYNC_ON
D:\ORACLE\ORADATA\MCRORAT03\INDEX02.ORA            ASYNC_ON
D:\ORACLE\ORADATA\MCRORAT03\DATA01.ORA             ASYNC_ON

Run the following


SET SERVEROUTPUT ON
DECLARE
  lat  INTEGER;
  iops INTEGER;
  mbps INTEGER;
BEGIN
-- DBMS_RESOURCE_MANAGER.CALIBRATE_IO (<DISKS>, <MAX_LATENCY>, iops, mbps, lat);
   DBMS_RESOURCE_MANAGER.CALIBRATE_IO (1,10, iops, mbps, lat);
 
  DBMS_OUTPUT.PUT_LINE ('max_iops = ' || iops);
  DBMS_OUTPUT.PUT_LINE ('latency  = ' || lat);
  dbms_output.put_line('max_mbps = ' || mbps);
end;
/

check the results of the I/O Calibration run 

SQL> select * from v$io_calibration_status 

check_STATUS
-------------
CALIBRATION_TIME
----------------
IN PROGRESS

COLUMN start_time FORMAT A20
COLUMN end_time FORMAT A20

SELECT TO_CHAR(start_time, 'DD-MON-YYY HH24:MI:SS') AS start_time,
       TO_CHAR(end_time, 'DD-MON-YYY HH24:MI:SS') AS end_time,
       max_iops,
       max_mbps,
       max_pmbps,
       latency,
       num_physical_disks AS disks
FROM   dba_rsrc_io_calibrate;
 
 
START_TIME          END_TIME              MAX_IOPS   MAX_MBPS  MAX_PMBPS    LATENCY      DISKS
------------------- ------------------- ---------- ---------- ---------- ---------- ----------
05-APR-016 14:55:26 05-APR-016 15:06:37       4111        520        230         11          1

MAX_PMBPS: Maximum megabytes per second of large I/O requests that can be sustained by a single process


The num_physical_disks input parameter is optional. By setting the num_physical_disks parameter to the approximate number of physical disks in the database's storage system, the calibration can be faster and more accurate.

At any time during the I/O calibration process, you can query the calibration status in the V$IO_CALIBRATION_STATUS view. After I/O calibration is successfully completed, you can view the results in the DBA_RSRC_IO_CALIBRATE table.                          