v_$log_history
dba_log_groups	v_$instance_log_group	v_$thread
v_$log      -- redo log file information from the control file
v_$logfile  -- redo log groups and members and their member status
v_$loghist  -- log history

Init File Parameters	log_checkpoint_timeout ... set to 0
Log Files Without Redundancy	LOGFILE
  GROUP 1 '/u01/oradata/redo01.log'SIZE 50M,
  GROUP 2 '/u02/oradata/redo02.log'SIZE 50M,
  GROUP 3 '/u03/oradata/redo03.log'SIZE 50M,
  GROUP 4 '/u04/oradata/redo04.log'SIZE 50M
Log Files With Redundancy
(Group with multiple members)	LOGFILE
 GROUP 1 ('/u01/oradata/redo1a.log','/u05/oradata/redo1b.log') SIZE 50M,
 GROUP 2 ('/u02/oradata/redo2a.log','/u06/oradata/redo2b.log') SIZE 50M,
 GROUP 3 ('/u03/oradata/redo3a.log','/u07/oradata/redo3b.log') SIZE 50M,
 GROUP 4 ('/u04/oradata/redo4a.log','/u08/oradata/redo4b.log') SIZE 50M;
 
-Forcing log file switches:
	
ALTER SYSTEM SWITCH LOGFILE; or ALTER SYSTEM CHECKPOINT;

-Clear A Log File If It Has Become Corrupt	

-This statement overcomes two situations where dropping redo logs is not possible: If there are only two log groups The corrupt redo log file belongs to the current group.
ALTER DATABASE CLEAR LOGFILE GROUP 4;

-Clear A Log File If It Has Become Corrupt And Avoid Archiving	Use this version of clearing a log file if the corrupt log file has not been archived.
ALTER DATABASE CLEAR UNARCHIVED LOGFILE GROUP 3;


he LGWR process NEVER EVER sends anything to a standby
In 11.2 only the LNS process name changes for Asynchronous (ASYNC) to NSA. In 11.2 for Synchronous (SYNC) it is called the NSS and this process writes to the standby in parallel with the LGWR write to the online redo log. 
Other than that it is pretty much the same as 11.1  .
In 12c it NSS/A is replaced by TTnn


=====================================================
Relocating redo log files
======================================================
	
ALTER DATABASE RENAME FILE '<existing_path_and_file_name>'
TO '<new_path_and_file_name>';
conn / as sysdba

SELECT member
FROM v_$logfile;

SHUTDOWN;

host

$ cp /u03/logs/log1a.log /u04/logs/log1a.log
$ cp /u03/logs/log1b.log /u05/logs/log1b.log

$ exit

startup mount

ALTER DATABASE RENAME FILE '/u03/logs/log1a.log' TO '/u04/oradata/log1a.log';

ALTER DATABASE RENAME FILE '/u04/logs/log1b.log' TO '/u05/oradata/log1b.log';

ALTER DATABASE OPEN

host

$ rm /u03/logs/log1a.log
$ rm /u03/logs/log1b.log

$ exit
SELECT member FROM v_$logfile;
----------------------------
Drop a redo log file group	
----------------------------
ALTER DATABASE DROP LOGFILE GROUP 4;

==========================================
Managing Log File Members
==========================================

1- Adding a single log file group member	

ALTER DATABASE ADD LOGFILE MEMBER '<log_member_path_and_name>' 
TO GROUP <group_number>;
ALTER DATABASE ADD LOGFILE MEMBER '/oracle/dbs/log2b.log' TO GROUP 2;

 1.1 Add a log group containing two members	
 
 ALTER DATABASE ADD LOGFILE GROUP <integer> (<logfile_path_and_name>, <logfile_path_and_name>) SIZE <integer><K | M>;
 
 ALTER DATABASE ADD LOGFILE GROUP 4 ('/u01/logs/redo4a.log', '/u02/logs/redo4b.log') SIZE 50M;

2. Drop Log File Group	
  ALTER DATABASE DROP [STANDBY] LOGFILE GROUP <integer>;
  SELECT group#, status FROM gv$log;

  ALTER DATABASE DROP LOGFILE GROUP 2;

3.Dropping log file group member	ALTER DATABASE DROP [STANDBY] LOGFILE MEMBER <logfile_member_path_and_name>;
  SELECT * FROM gv$logfile
           WHERE group# IN ( SELECT group#
                             FROM gv$log
                             WHERE status = 'INACTIVE');
  ALTER DATABASE DROP LOGFILE MEMBER '/oracle/dbs/log3c.log';
3. Drop Log File by Descriptor	
   ALTER DATABASE DROP [STANDBY] LOGFILE <file_name>;
   ALTER DATABASE DROP LOGFILE '/oracle/dbs/log3c.log';
============================= 
 Managing Log File Threads
=============================

 1.Add a redo log containing two members to a thread	
  ALTER DATABASE ADD LOGFILE THREAD <integer> GROUP <integer> (<logfile_path_and_name>, <logfile_path_and_name>);
 
 ALTER DATABASE ADD LOGFILE THREAD 5 GROUP 3 ('/u03/oradabase/redo315.log', '/home/oracle/orabase/redo325.log');
 
 2.Dumping Log Files
  Dumping a log file to trace	ALTER SYSTEM DUMP LOGFILE '<logfile_path_and_name>'
   DBA MIN <file_number> <block_number>
   DBA MAX <file_number> <block_number>;
or
  ALTER SYSTEM DUMP LOGFILE '<logfile_path_and_name>' TIME MIN <value> TIME MIN <value>

conn uwclass/uwclass
alter session set nls_date_format='MM/DD/YYYY HH24:MI:SS';
SELECT SYSDATE FROM DUAL;

  CREATE TABLE test AS SELECT owner, object_name, object_type
  FROM all_objects
  WHERE SUBSTR(object_name,1,1) BETWEEN 'A' AND 'W';

   INSERT INTO test(owner, object_name, object_type)
   VALUESß('UWCLASS', 'log_dump', 'TEST');
    COMMIT;

    conn / as sysdba

    SELECT ((SYSDATE-1/1440)-TO_DATE('01/01/2007','MM/DD/YYYY'))*86400 ssec
    FROM DUAL;

      ALTER SYSTEM DUMP LOGFILE 'c:\oracle\product\oradata\orabase edo01.log' TIME MIN 579354757;    OR ALTER SYSTEM DUMP LOGFILE ‘c:\oracle\product\oradata\orabase\redo01.log’ SCN MIN 103243  SCN MAX 103294;

=================================
--show log switches by date
=================================

col c1 format a10 heading "Month"
col c2 format a25 heading "Archive Date"
col c3 format 99999 heading "Switches"

compute AVG of C on A
compute AVG of C on REPORT
break on A skip 1 on REPORT skip 1

  Select 
   to_char(trunc(first_time), 'Month') c1,
   to_char(trunc(first_time), 'Day : DD-Mon-YYYY') c2,
   count(*) c3
  From 
    v$log_history
  Where 
   trunc(first_time) > last_day(sysdate-100) +1
    group by  trunc(first_time);
   
==============================================================   
 -- Daily Count and Size of Redo Log Space (Single Instance)
==============================================================
--
SELECT A.*,
Round(A.Count#*B.AVG#/1024/1024) Daily_Avg_Mb
FROM
(
   SELECT
   To_Char(First_Time,'YYYY-MM-DD') DAY,
   Count(1) Count#,
   Min(RECID) Min#,
   Max(RECID) Max#
FROM
   v$log_history
GROUP BY 
   To_Char(First_Time,'YYYY-MM-DD')
ORDER
BY 1 DESC
) A,
(
SELECT
Avg(BYTES) AVG#,
Count(1) Count#,
Max(BYTES) Max_Bytes,
Min(BYTES) Min_Bytes
FROM
v$log
) B
;


select 
   recid, 
   thread#, 
   sequence#, 
   resetlogs_change#,
   resetlogs_time
from 
   v$log_history
where 
   rownum < 20;


========================================

Disable Log Archiving

conn / as sysdba

SHUTDOWN;

STARTUP MOUNT EXCLUSIVE;

ALTER DATABASE NOARCHIVELOG;

ALTER DATABASE OPEN;

ALTER SYSTEM SET "_disable_logging"=TRUE;

===============================================                                                                                                                            
The redo buffer allocation retries Oracle metric is the total number of retries needed to allocate space in the redo buffer. 
  SELECT name, value                           
  FROM V$SYSSTAT                               
 WHERE name = 'redo buffer allocation retries';                      
                      
                      
NAME                                VALUE
------------------------------ ----------
redo buffer allocation retries       3357


=========================================
When is an ArchiveLog created ?
=========================================

Select sequence#, substr(name,1,length(name)) archive,creator, to_char(first_time,'DD-MON HH24:MI') "start", to_char(completion_time,'DD-MON HH24:MI') "end",first_change#,next_change#,archived
from v$archived_log
where first_time > sysdate-1
order by 1;
========================
INCREMENTAL BACKUP
========================
- Level 0 incremental backup of the database

BACKUP INCREMENTAL LEVEL 0 DATABASE;
This example makes a differential level 1 backup of the SYSTEM tablespace and datafile tools01.dbf. back up those data blocks changed since the most recent level 1 or level 0 backup
BACKUP INCREMENTAL LEVEL 1
  TABLESPACE SYSTEM
  DATAFILE 'ora_home/oradata/trgt/tools01.dbf';

cumulative level 1 backup of the tablespace users, backing up all blocks changed since the most recent level 0 backup.
BACKUP INCREMENTAL LEVEL = 1 CUMULATIVE
  TABLESPACE users;