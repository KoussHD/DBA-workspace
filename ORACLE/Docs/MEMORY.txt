Take 10% for the OS
The remaining part divide by 2.
(So basically 45%) and that I use as a MAX boundary for SGA. (You don't have to use it all at once, it is better to start lower so you can increase later on if needed)
Also if you have 2 or 3 instances, you will need to divide this RAM among the number of instances, as long as MAX is respected.

The other 45% is for PGA and other processes.
Check with ipcs -m after to see your memory
structure is as intended :)


Dialect of UNIX	   RAM display command
------------------ --------------------------
DEC-UNIX	   uerf -r 300 | grep -i mem
Solaris	           prtconf|grep -i mem
AIX	           lsdev -C|grep mem
Linux	           free
HP/UX	           swapinfo -tm



Display PGA area sizes.

Here we can see the values for sort_area_size and hash_area_size for our Oracle database. To compute the value for the size of each PGA RAM region, we can write a quick data dictionary query against the v$parameter view:

set pages 999;

column pga_size format 999,999,999

select
    1048576+a.value+b.value   pga_size
from
   v$parameter a,
   v$parameter b
where
   a.name = 'sort_area_size'
and
   b.name = 'hash_area_size'
;

A dictionary query to compute PGA size.

The output from this data dictionary query shows that every connected Oracle session will about 2.5 megabytes of RAM memory for the Oracle PGA.

PGA_SIZE
------------
   2,621,440  

Now, if we were to multiply the number of connected users by the total PGA demands for each connected user, we will know exactly how much RAM memory in order to reserve for connected sessions.

Getting back to our example, let's assume that we have a high water mark of 100 connects sessions to our Oracle database server. We multiply 100 by the total area for each PGA memory region, 
and we can now determine the maximum size of our SGA:

Total RAM on Windows Server	1250 MB
    Less:	 
    Total PGA regions for 100 users:	250 MB
    RAM reserved for Windows (20 %)	250 MB
 	----------
    RAM for SGA & buffers	750 MB


A Script for estimating Total PGA RAM

In SQL*Plus, you can accept a parameter and then reference it inside your query by placing an ampersand in front of the variable name. In the simple example below, we declare a variable called myparm and direct SQL*Plus to accept this value when the script is executed:

set heading off
set echo on

accept myparm number prompt 'Choose a number between 1 and 10: '

select 'You chose the number '||&myparm from dual;

Our goal is to create a script called pga_size.sql. This script will prompt you for the high-water mark of connected users, and then compute the sum of all PGA RAM to be reserved for dedicated Oracle connections.
 In this example, we have a 2-meg overhead for MS-Windows PGA sessions.

Here is the finished script:

set pages 999;
column pga_size format 999,999,999

accept hwm number prompt 'Enter high-water mark of connected users:'

select
    &hwm*(2048576+a.value+b.value) pga_size
from
   v$parameter a,
   v$parameter b
where
   a.name = 'sort_area_size'
and
   b.name = 'hash_area_size'
;

A  script to display the memory used by any specific session would look something like this:

display_session.ram.sql

select
    to_char(ssn.sid, '9999') || ' – ' || nvl(ssn.username,
    nvl(bgp.name, 'background')) || nvl(lower(ssn.machine), ins.host_name) ssession,
    to_char(prc.spid, '999999999')                       pid_thread,
    to_char((se1.value / 1024) / 1024, '999g999g990d00') current_size_mb,
    to_char((se2.value / 1024) / 1024, '999g999g990d00') maximum_size_mb
from
    v$statname  stat1,
    v$statname  stat2,
    v$session   ssn,
    v$sesstat   se1,
    v$sesstat   se2,
    v$bgprocess bgp,
    v$process   prc,
    v$instance  ins
where
 --(See CODE DEPOT for full working script)
    stat1.name = 'session pga memory'
and
    stat2.name = 'session pga memory max' 
and
    se1.sid = ssn.sid 
and
    se2.sid = ssn.sid 
and
    se2.statistic# = stat2.statistic# 
and
    se1.statistic# = stat1.statistic# 
and
    ssn.paddr = bgp.paddr(+) 
and
    ssn.paddr = prc.addr(+)  
ORDER BY maximum_size_mb DESC;