OS block size -- how the operating system manages things at the lowest level
IO size -- how much IO the controllers can do in one fell swoop (hardware thing)
Stripe Size -- when setting up RAID, you many times "stripe" the disks -- using more then one disk to appear as a single disk.
If your strip size was one meg and you wrote 10 meg of data -- 1 meg goes to one disk , 1 meg to the other, 1 meg to the first and so on.
IO size and OS block size-- are not the same, IO size is generally MUCH larger. 
How Long will the Restore Take?
If restoring to the same host, and all loads being equal, then a restore operation should take a similar time as the backup. Look at Elapsed Time from the restore preview:
recover database preview; is possible after the backup
=========================================================================================================================================
Minimum, configuration :
==========================
CONFIGURE RETENTION POLICY TO REDUNDANCY 2 ;
CONFIGURE RETENTION POLICY TO RECOVERY WINDOW OF 7 DAYS;


SQL> ALTER  SYSTEM SET log_archive_dest_1='LOCATION=USE_DB_RECOVERY_FILE_DEST';
%s – log sequence number
%S – log sequence number, padded with zero
%t – thread number
%T – thread number, padded with zero
%a – activation id
%d – database id
%r – reset logs id

---SQL> alter system set log_archive_format='%d_log.%s_%t_%r.arc' scope=spfile;   DB_log.13_1_8971755.ARC'
C:> set NLS_DATE_FORMAT=dd-MON-YYYY hh24:mi:ss
RMAN> 
  CONFIGURE BACKUP OPTIMIZATION ON;
  CONFIGURE CONTROLFILE AUTOBACKUP ON;
  CONFIGURE DEVICE TYPE DISK PARALLELISM 4 BACKUP TYPE TO COMPRESSED BACKUPSET;
  CONFIGURE CONTROLFILE AUTOBACKUP FORMAT FOR DEVICE TYPE DISK TO 'C:\oracle\product\10.2.0\flash_recovery_area\DEV\CONTROLFILE\cf_%F';
  CONFIGURE DB_UNIQUE_NAME 'mtlstd' CONNECT IDENTIFIER  'boisbriand';
  CONFIGURE CHANNEL DEVICE TYPE DISK FORMAT 'C:\oracle\product\10.2.0\flash_recovery_area\DEV\BACKUPSET\%d_bkp_%T.%t_s%s_s%p'; backup_db_%d_S_%s_P_%p_T_%t
  BACKUP FORMAT '%backup_folder%\%ORACLE_SID%\BD_%%d_%%s_%%p_%%T_%%U'DATABASE;
  BACKUP FORMAT '%backup_folder%\%ORACLE_SID%\ARCH_%%d_%%s_%%T_%%U'ARCHIVELOG ALL;        
   
   ‘arc_%d_%s_%T.bak’ 
  %a	Specifies the activation ID of the database.
  %t - 4-byte timestamp (backup set number of seconds elapsed since a fixed reference time)
  %d – database id
  %D - specifies the current day of the month from the Gregorian calendar in format DD.
  %e -	Specifies the archived log sequence number.
  %h	Specifies the archived redo log thread number.
  %I	Specifies the DBID.
  %M	Specifies the month in the Gregorian calendar in format MM.
  %N	Specifies the tablespace name. This substitution variable is only valid when backing up datafiles as image copies.
  %n	Specifies the name of the database, padded on the right with x characters to a total length of eight characters. For example, if prod1 is the database name, then the padded name is prod1xxx.
  %s - Backup set number
  %p - Backup piece number
  %n - Specifies the database name, padded on the right with 'x' characters to a total length of 8 characters. Example:PROD1==> PROD1xxx is the padded database name.
  %u - 8-character name constituted by compressed representations of the backup set number and the time the backup set was created.
  %c - Copy number of backup piece within set of duplexed backup pieces.If 'set duplex' command not used => for regular backup sets variable = 1  and 0 for proxy copies.
       If set duplex used, the variable identifies copy number: 1, 2, 3, or 4.
  %U - Shorthand for %u_%p_%c that guarantees uniqueness in generated backup filenames(is the default in Oracle).
  %f - Specifies the absolute file number (see Example 3-22).
  %F - Combines the DBID, day, month, year, and sequence into a unique and repeatable generated name. This variable translates into c-IIIIIIIIII-YYYYMMDD-QQ,
             IIIIIIIIII stands for the DBID / YYYYMMDD is a time stamp / QQ is the sequence in hexadecimal number from 00 to FF
  
  %T - Specifies the year, month, and day in the Gregorian calendar in this format: YYYYMMDD.
  %t	Specifies the backup set time stamp, which is a 4-byte value derived as the number of seconds elapsed since a fixed reference time
  %Y	Specifies the year in this format: YYYY.
  %%	Specifies the percent (%) character. For example, %%Y translates to the string %Y.
----check policy
SQL> SELECT NAME, VALUE FROM V$RMAN_CONFIGURATION WHERE NAME LIKE '%ARCHIVELOG DELETION POLICY%';

===============================
ARCHIVELOG DELETION POLICY  
===============================
1. Delete logs after after they're shipped to destinations:
RMAN > CONFIGURE ARCHIVELOG DELETION POLICY TO SHIPPED TO ALL STANDBY;
2. Delete logs after they're applied on standby destinations:
RMAN> CONFIGURE ARCHIVELOG DELETION POLICY TO APPLIED ON ALL STANDBY;

Note: the "obsolete" functions of RMAN don't work with archivelog deletion policy. As you can see the archivelogs don't appear as obsolete even if they were applied in Standby Database.
However delete archivelog all will check deletion policy   : 
RMAN> delete obsolete/report obsolete;  
      no obsolete backups found 

====================================================================
================================================================
RMAN-20207: UNTIL TIME or RECOVERY WINDOW is before RESETLOGS time :-(  
 
 ACTION : RMAN > reset database to incarnation 2; 
 
1- No Tape :   7-Day Window,  - Scripts
     Daily: Roll forward image copy and take incremental backup
                                                                                                              BACKUP BACKUPSET/BACKUP RECOVERY AREA allows to backup the backup to destinstion / ()
   # daily disk (keeps 7-day-old image copy)                                                                  Note: Verified by Documentation checking clause "FOR RECOVER OF COPY" to find DEFAULT used for INCREMENTAL MERGE Backup:                                                                                                            
                                                                                                              .                                                                                                                                                                      
  RMAN> run                                                                                                   10gR2: "FOR RECOVER OF COPY" Incremental Merge Backups are by default CUMULATIVE.   (up to a including 10.2.0.4 )                                                                 
    {recover copy of database with tag DB_BACKUP                                                              11gR1: "FOR RECOVER OF COPY" Incremental Merge Backups are by default CUMULATIVE.   (up to a including 11.1.0.7 )    
    until time'sysdate-8';                                                                                    11gR2: "FOR RECOVER OF COPY" Incremental Merge Backups are by default DIFFERENTIAL.  >= 11.2.                        
    backup incremental level 1 for recover of copy with tag DB BACKUP database;                               sql> BACKUP BACKUPSET ALL DELETE INPUT;     BACKUP BACKUPSET 1, 2DELETE INPUT;                                                                                   
    }                                                                                                                                                            
                                                                                                                 
  1.2- Real life example:  
   RUN {
   RECOVER COPY OF DATABASE WITH TAG INC_BACKUP UNTIL TIME 'SYSDATE-2';
   BACKUP INCREMENTAL LEVEL 1 FOR RECOVER OF COPY WITH TAG INC_BACKUP DATABASE PLUS ARCHIVELOG DELETE INPUT;  
   DELETE NOPROMPT OBSOLETE DEVICE TYPE DISK ;}
    
    
2- With Tape:  7-Day Window,  - Scripts
     Daily incremental and back up FRA to tape every 2 days
   # Daily disk (7 day window using tape)
    RMAN> run{
      recover copy of database with tag DB_BACKUP;
      backup incremental level 1 for recover of copy with tag DB_BACKUP database;
      }
   # Tape backup executed once every 2 days	
   RMAN> run 
   { backup recovery area;
     delete obsolete device type sbt;  
     }
     
     
 3- separated 
 RMAN> run 
   {backup
   incremental level 0
   spfile format ‘spfile_%d_%s_%T.bak’  tag ‘spfile backup’
   database include current controlfile format ‘data_%d_%s_%T.bak’  tag ‘data backup’ 
   archivelog all format ‘arc_%d_%s_%T.bak’  tag ‘archive backup’ delete input;    
   }
     

BACKUP TAG 'INC_BACKUP' ARCHIVELOG ALL NOT BACKED UP DELETE ALL INPUT;   
 
 
 
Convert timestamp %t format to date:
SQL> select (to_date('1987-06-26 00:00:00', 'YYYY-MM-DD HH24:MI:SS')+ 903731900/24/60/60) from dual;
  
-----------------------------------

- Enabling Block Change Tracking (BCT)
  To enhance performance of the incremental backups, you should really look at enabling Block Change Tracking…
 SQL> SELECT status from v$block_change_tracking;
 SQL> ALTER database enable block change tracking using file '/u02/oradata/snapdb/block_change_tracking.dbf';
   I’ll write-up a separate post later on about BCT, in some more detail…but when enabled, it keeps a track of any changed blocks so RMAN doesn’t have to scan the entirety of each datafile, for every incremental backup, thus saving quite a bit of processing time.

- Some useful image copy RMAN commands

list copy of database;
list copy of datafile 1;
list copy of tablespace system;
backup as copy datafile 1;
- Manuel level 0 copy to multiple locations
run { 
backup as copy incremental level 0 format '/path/mount1/%U' tag 'MIB_LEVEL_0'
tablespace SYSTEM, UNDOTBS1; 
backup as copy incremental level 0 format '/path/mount2/%U' tag 'MIB_LEVEL_0'
tablespace SYSAUX, USERS; 
backup as copy incremental level 0 format '/path/mount3/%U' tag 'MIB_LEVEL_0'
tablespace TEST1, TEST2; 
 }
======================================
           RMAN COLD BACKUP 
======================================     
Windows:  RESET DEVICE DISK PROPERTY
RMAN> configure archivelog deletion policy clear; 

CONFIGURE CHANNEL DEVICE TYPE DISK CLEAR;
 device type disk format ‘+FRA/DEV/rman/level0_backup_%d_S_%s_P_%p_T_%t’;

RMAN> 
RUN {  ALLOCATE CHANNEL C1 DEVICE TYPE DISK;
SHUTDOWN IMMEDIATE;
STARTUP MOUNT;                                                         
BACKUP as compressed backupset
spfile format ‘C:\oracle\product\10.2.0\flash_recovery_area\DEV\SPFILE\spfile_%d_%s_%T.bak’  tag ‘spfile backup’
DATABASE tag='DB_COLD_BKP_FULL';
ALTER DATABASE OPEN;}

RMAN> run 
{ ALLOCATE CHANNEL C1 DEVICE TYPE DISK;
SHUTDOWN IMMEDIATE;
STARTUP MOUNT
backup as compressed backupset tag "full_backup"
database;
alter database open;
}  

=====================================
         HOT BACKUP
=====================================

RMAN> RUN { ALLOCATE CHANNEL T1 TYPE DISK;
BACKUP as compressed backupset tag='DB_HOT_BKP_FULL' DATABASE;
SQL 'ALTER SYSTEM SWITCH LOGFILE'; 
BACKUP as compressed backupset tag='DB_HOT_BKP_FULL' FORMAT 'C:\oracle\product\10.2.0\flash_recovery_area\DEV\backupset\flash_recovery_area/arch-%d-id-%I_S-%e_s%s.arc'
ARCHIVELOG ALL DELETE INPUT;}
or 

RMAN> RUN {                                                         
ALLOCATE CHANNEL T1 TYPE DISK;
BACKUP as compressed backupset  tag='DB_HOT_BKP_FULL' DATABASE PLUS ARCHIVELOG DELETE INPUT;}


NOTE: Use delete all input if you are archiving to multiple locations.



Resume iterrupted backup
----------------------- 
RMAN> run {
BACKUP 
  NOT BACKED UP SINCE TIME 'SYSDATE-1'
  MAXSETSIZE 500M
  DATABASE PLUS ARCHIVELOG;}
                                                           
================ 
separate spfile    
================    
RMAN> 
RUN {SET CONTROLFILE AUTOBACKUP OFF; backup format='C:\oracle\product\10.2.0\flash_recovery_area\sp_backup.f' spfile;}     
  --     
RMAN wouldn't backup the Online Redo Logs.
So you have to ALTER DATABASE OPEN RESETLOGS if the database had been OPENed since that backup and/or redolog files have been deleted) 


=================
archivelog
=================
RMAN> BACKUP ARCHIVELOG FROM TIME 'SYSDATE-10' UNTIL TIME 'SYSDATE-7';
RMAN> BACKUP archivelog sequence between 16 and 19;
RMAN> BACKUP archivelog sequence 15;
=============================
RMAN OPERATION LOG OUTPUT
============================
use the following query

set lines 200
set pages 1000
select output
from GV$RMAN_OUTPUT
where session_recid = &SESSION_RECID
order by recid;

- You need SESSION_RECID + SESSION_STAMP,and you can get them from the following query

SQL> select session_recid,session_stamp,status from v$rman_status where start_time like '11-APR-16' and status ='COMPLETED';
(change the date according to your needs for which you want to see the log)

=========================================================================
                                  RESTORE HOT AND COLD BACKUP
=========================================================================
 - Recover Spfile et pfile 
--- Text
RMAN> restore spfile to pfile '..\BACKUP\spfile_20160211.txt' from autobackup;
--- Binairy
RMAN> restore spfile to '..\BACKUP\spfile_20160211_BIN.ora' from autobackup;

RMAN > RESTORE ARCHIVELOG FROM SEQUENCE xx UNTIL SEQUENCE xx;
RMAN> restore spfile to pfile '..\BACKUP\spfile_20160211.txt' from autobackup; 

RMAN> STARTUP NOMOUNT;
RMAN > restore controlfile from 'C:\oracle\product\10.2.0\flash_recovery_area\DEV\CONTROLFILE\CF_C-3972799270-20160213-05';
RUN {
ALLOCATE CHANNEL C1 TYPE DISK;
RESTORE DATABASE;
RECOVER DATABASE; 
ALTER DATABASE | OPEN RESETLOGS} ;
}

RMAN> RUN {
  shutdown;
  startup nomount;
  set until time "to_date('03-Aug-10 17:50:00','DD-MON-YYYY HH24:MI:SS')";
  RESTORE CONTROLFILE; # not needed in catalog mode. Autobakup
  ALTER DATABASE MOUNT; 
  RESTORE DATABASE;
  RECOVER DATABASE;
}

rman target / 
RMAN> list incarnation;
reset database to incarnation 2;
 RUN {
  shutdown force mount;
  set until time "to_date('23-feb-2016 17:00:00','DD-MON-YYYY HH24:MI:SS')";
  RESTORE DATABASE;
  RECOVER DATABASE;
}

- sql "alter session set NLS_DATE_FORMAT=''dd-MON-YYYY hh24:mi:ss''";

        34 23-feb-2016 01:20:00       9793934 23-feb-2016 03:06:05      9809084 -----------SCN
c.Récupération de la copie sauvegardé :
 Alternatively, you can recover your database from the image copy in the same way you would with any other backup set:

       - Set Environment Variable for example: [NLS_LANG was not set (empty) ERROR ORA-01841 (full) year must be between -4713 and +4713 / +9999 and must not be 0]
       export NLS_LANG=AMERICAN_AMERICA.AL32UTF8
       echo $NLS_LANG
1. RMAN> run { SHUTDOWN IMMEDIATE;
   STARTUP MOUNT;                
   SET UNTIL TIME "TO_DATE('23-feb-2016 17:00:00','DD-MON-YYYY HH24:MI:SS')";                                                                                   
   RESTORE DATABASE FROM TAG INC_BACKUP;                                            
   RECOVER DATABASE;
   ALTER DATABASE OPEN RESETLOGS;}           ---------Worked with a resetlogs on the 25th at 17h 
 
2. RMAN> RUN {
   SHUTDOWN ABORT;
   STARTUP MOUNT;   
   SWITCH DATABASE TO COPY;
   RECOVER DATABASE;
   ALTER DATABASE OPEN;}


  ---------------------- Using the script above, RMAN knows about the image copies and will use these to restore and recover your database. 
 rman target /
switch datafile 5 to copy; recover datafile 5;   (same with tablsepace) 
sqlplus / as sysdba
alter database datafile 5 online;
---------------------------------------------------------------------------------------------------------------------------------------
                                   PREVIEW VALIDATE 
---------------------------------------------------------------------------------------------------------------------------------------

RMAN> RUN { set until time "to_date('15-02-2016 17:32:05','dd-MM-YYYY hh24:mi:ss')"; restore database preview;} [validate|preview]
RMAN>  RUN { set until time "to_date('24-02-2016 17:32:05','dd-MM-YYYY hh24:mi:ss')"; restore database preview summary ;}
RMAN> restore database preview summary ;
RMAN> restore database preview summary from tag INC_BACKUP validate;
RMAN> restore database preview summary from tag DB_HOT_BKP_FULL UNTIL TIME '23-FEB-2016 15:45:00';
RMAN> restore database preview summary from tag INC_BACKUP      UNTIL TIME '23-FEB-2016 15:45:00';
RMAN> restore database until time '23-FEB-2016 15:45:00' validate; ----easiest



DEV> select SCN_TO_TIMESTAMP(9793934) from dual;

SCN_TO_TIMESTAMP(9040770)
---------------------------------------------------------------------------
16-02-15 01:24:03,000000000

===================================================
LIST BACKUPS
===================================================
# lists backups of all files in database
LIST BACKUP OF DATABASE; 
# lists copy of specified datafile    
LIST COPY OF DATAFILE 'ora_home/oradata/trgt/system01.dbf'; 
# lists specified backup set
LIST BACKUPSET 213; 
# lists datafile copy
LIST DATAFILECOPY '/tmp/tools01.dbf';
------
# specify a backup set by tag
LIST BACKUPSET TAG 'weekly_full_db_backup';
# specify a backup or copy by device type
LIST COPY OF DATAFILE 'ora_home/oradata/trgt/system01.dbf' DEVICE TYPE sbt;
# specify a backup by directory or path
LIST BACKUP LIKE '/tmp/%';
# specify a backup or copy by a range of completion dates
LIST COPY OF DATAFILE 2 COMPLETED BETWEEN '10-DEC-2002' AND '17-DEC-2002';
# specify logs backed up at least twice to tape
LIST ARCHIVELOG ALL BACKED UP 2 TIMES TO DEVICE TYPE sbt;

LIST BACKUP BY FILE; # shows backup sets, proxy copies, and image copies
LIST COPY BY FILE;   # shows only disk copies
LIST BACKUP;       # lists backup sets, image copies, and proxy copies
LIST BACKUPSET;    # lists only backup sets and proxy copies
LIST COPY;         # lists only disk copies
LIST EXPIRED BACKUP BY FILE;
Examples :
-----------
RMAN> LIST ARCHIVELOG ALL;
RMAN> LIST BACKUP OF ARCHIVELOG FROM TIME='28-JUN-2013' UNTIL TIME='28-JUN-2013';
RMAN> LIST BACKUP OF ARCHIVELOG FROM SEQUENCE UNTIL SEQUENCE ;

RMAN> LIST BACKUP;
RMAN> LIST BACKUP OF DATABASE;
RMAN> LIST BACKUP OF DATAFILE 1;
RMAN> LIST BACKUP SUMMARY;
RMAN> LIST INCARNATION;
RMAN> LIST BACKUP BY FILE;
RMAN> LIST COPY OF DATABASE ARCHIVELOG ALL;
RMAN> LIST COPY OF DATAFILE 1, 2, 3;
RMAN> LIST BACKUP OF DATAFILE 11 SUMMARY;
RMAN> LIST BACKUP OF ARCHIVELOG FROM SEQUENCE 1437;
RMAN> LIST CONTROLFILECOPY "/tmp/cntrlfile.copy";
RMAN> LIST BACKUPSET OF DATAFILE 1;
RMAN> LIST FAILURE;
RMAN> LIST FAILURE 641231 detail;
--------------------------------------------------------------                                                                
RMAN> list backup summary completed between "to_date('14-02-2016 00:00:00','DD-MM-YYYY  HH24:MI:SS')" and "to_date('22-02-2016 17:00:00','DD-MM-YYYY HH24:MI:SS')" RECOVERABLE| UNTIL SCN 9633079|UNTIL TIME| UNTIL SEQUENCE;
RMAN> list backup summary completed BEFORE '25-FEB-2016' RECOVERABLE UNTIL TIME '23-FEB-2016 17:00:00';
RMAN> list backup SUMMARY(by backup summary) RECOVERABLE UNTIL TIME '23-FEB-2016 17:00:00';
RMAN> list backup by  file TAG DB_HOT_BKP_FULL  RECOVERABLE UNTIL TIME '23-FEB-2016 17:00:00';     
RMAN> list backup summary completed BEFORE '25-FEB-2016' RECOVERABLE | UNTIL SCN 9633079|UNTIL TIME| UNTIL SEQUENCE; 
RMAN> list backup summary tag INC_BACKUP             RECOVERABLE UNTIL TIME '23-FEB-2016 17:00:00';
RMAN> list backup by BACKUP SUMMARY  tag INC_BACKUP  RECOVERABLE UNTIL TIME '23-FEB-2016 17:00:00';
RMAN> list backup by FILE TAG INC_BACKUP  RECOVERABLE UNTIL TIME '23-FEB-2016 17:00:00';
RMAN> list copy of database tag INC_BACKUP RECOVERABLE UNTIL TIME '23-FEB-2016 17:00:00';                                             
RMAN> list copy of database COMPLETED BEFORE '24-FEB-2016' RECOVERABLE | UNTIL SCN 9633079|UNTIL TIME| UNTIL SEQUENCE;
RMAN>LIST COPY  OF DATABASE COMPLETED AFTER 'SYSDATE-5';	
RMAN> list backup summary completed between "to_date('14-02-2016 00:00:00','DD-MM-YYYY HH24:MI:SS')" and "to_date('16-02-2016 17:00:00','DD-MM-YYYY HH24:MI:SS')";

List of Backups
===============
Key     TY LV S Device Type Completion Time     #Pieces #Copies Compressed Tag
------- -- -- - ----------- ------------------- ------- ------- ---------- ---
58      B  1  A DISK        2016-02-22 09:38:55 1       1       NO         TAG20160222T093808
LIST BACKUP OF ARCHIVELOG FROM TIME 'SYSDATE-1';


RMAN> restore database preview summary from tag INC_BACKUP;

--------------
REPORT on BACKUPS  
---------------
RMAN> REPORT NEED BACKUP;

File #bkps Name
---- ----- -----------------------------------------------------
1    1     C:\ORACLE\PRODUCT\10.2.0\ORADATA\DEV\DEV\SYSTEM01.DBF

2 - with Different Retention Policies

RMAN> REPORT NEED BACKUP RECOVERY WINDOW OF n DAYS;   // REPORT NEED BACKUP RECOVERY WINDOW OF 2 DAYS DATABASE DEVICE TYPE sbt;
RMAN> REPORT NEED BACKUP REDUNDANCY n;
RMAN> REPORT NEED BACKUP DAYS n;
RMAN> REPORT NEED BACKUP INCREMENTAL n;
3 - with Tablespaces and Datafiles
RMAN> REPORT NEED BACKUP RECOVERY WINDOW OF 2 DAYS DATABASE SKIP TABLESPACE TBS_2;
RMAN> REPORT NEED BACKUP REDUNDANCY 2 DATAFILE 1;
RMAN> REPORT NEED BACKUP TABLESPACE TBS_3; # uses configured retention policy // DEVICE TYPE sbt; 
RMAN> REPORT NEED BACKUP INCREMENTAL 2; # checks databasefor files that need more than 2 incrementals during recovery
RMAN> REPORT NEED BACKUP DEVICE TYPE dbt;
 

4- unrecoverability :
RMAN> REPORT UNRECOVERABLE;
===
SHOW 
=====
RMAN> show ALL;
RMAN> show channel for device type disk  ;
RMAN> show channel for device type disk/sbt_tape;
RMAN> 
===========
delete
=============
RMAN> DELETE BACKUPPIECE 101;
RMAN> DELETE CONTROLFILECOPY '/tmp/control01.ctl';
RMAN> DELETE NOPROMPT ARCHIVELOG ALL; 
RMAN> DELETE NOPROMPT ARCHIVELOG UNTIL SEQUENCE = 300;
RMAN> DELETE NOPROMPT ARCHIVELOG ALL COMPLETED BEFORE "to_date('20-MAY-2016 23:00:00','DD-MON-YYYY HH24:MI:SS')";
RMAN> DELETE BACKUP TAG='before_upgrade';
RMAN> DELETE BACKUP OF TABLESPACE users DEVICE TYPE sbt; # delete only from tape
RMAN> DELETE COPY OF CONTROLFILE LIKE '/tmp/%';  # 
RMAN> DELETE BACKUP; 
RMAN> DELETE ARCHIVELOG ALL  BACKED UP 3 TIMES TO sbt; 
RMAN> DELETE OBSOLETE;
RMAN> DELETE OBSOLETE REDUNDANCY = 3;
RMAN> DELETE OBSOLETE RECOVERY WINDOW OF 3 DAYS;
RMAN> DELETE COPY OF DATABASE COMPLETED BEFORE "SYSDATE-3";
RMAN> DELETE COPY OF DATABASE tag "TAG20141111T084112";



How to delete obsolete TAPE backups via RMAN, when the Media Management Layer (MML Software not installed) 
is NOT available anymore.??
Allocate a maintenance channel with the dummy sbt API and run the DELETE FORCE OBSOLETE.
    RMAN> allocate channel for maintenance device type sbt parms 'SBT_LIBRARY=oracle.disksbt, ENV=(BACKUP_DIR=/tmp)';
    RMAN> delete force obsolete;
    RMAN> delete noprompt force obsolete device type sbt_tape;
    RMAN>release channel;
    inside a script
        ALLOCATE channel FOR maintenance device type sbt parms 'SBT_LIBRARY=oracle.disksbt, ENV=(BACKUP_DIR=/tmp)';  
        DELETE NOPROMPT FORCE OBSOLETE device type sbt_tape; 			                              
        RELEASE CHANNEL;                                                                                      
        allocate channel for maintenance type disk;                                                           
        DELETE NOPROMPT FORCE OBSOLETE device type DISK; 			                              
        RELEASE CHANNEL;                                                                                      
        RUN 									                              
        { ...action son the RUN BLOCK must be separated from maintenace tasks									                              


RMAN> list incarnation;          |   OR   SQL> select incarnation#, resetlogs_change# from v$database_incarnation;
List of Database Incarnations                     
DB Key  Inc Key DB Name  DB ID            STATUS  Reset SCN  Reset Time
------- ------- -------- ---------------- --- ---------- ----------
1       1       DEV      3972799270       CURRENT 1          30-OCT-15


====================================
delete archivelogs from standby db
====================================
[oracle@ora1-2 u01]$ cat delete.sh
ORACLE_HOME=<ORACLE_HOME path>
export ORACLE_HOME
PATH=$PATH:$ORACLE_HOME/bin
export PATH
rman target sys/<pwd>@<standbydb> <<EOF
spool log to "/u01/delete.log";
run
{
delete force noprompt archivelog all completed before 'SYSDATE-4';
}
EXIT;
EOF

This would delete all the archives before SYSDATE-4. If this does not work, then you can try deleting them by checking the sequence that was last applied and delete until that sequence using RMAN.
 
SQL> select thread#,max(sequence#) from v$archived_log where applied='YES' group by thread#;
 
 
RMAN>delete archivelog until sequence <above value>;
 


----------------------
troublshooting :
-----------------------  
1) ERROR at line 1:
ORA-01113: file 1 needs media recovery
ORA-01110: data file 1: 'C:\ORACLE\PRODUCT\10.2.0\ORADATA\DEV\DEV\SYSTEM01.DBF'

DEV>  recover database using backup controlfile until cancel;
ORA-00279: changement 8846902 genere a 02/11/2016 15:03:17 requis pour thread 1
ORA-00289: suggestion : C:\ORACLE\PRODUCT\10.2.0\FLASH_RECOVERY_AREA\DEV\ARCHIVELOG\2016_02_13\O1_MF_1_411_%U_.ARC
ORA-00280: le changement 8846902 pour le thread 1 se trouve au no de sequence 411


TIP:
   1) Never use: "set until time" for your recovery needs. Always use: "set until scn" for your recovery needs.
	   The "time" portion is a great feature, but problematic and last I read, oracle only guarantees a 5 minute window closest to your time.
	   
	   The SCN is exact and works if you do the preperation steps below.
	   
   2) Get the greatest of either absolute_fuzzy_change# or checkpoint_change# for your datafile backups.
    The quickest way to roll forward just beyond the backup to open resetlogs is to query v$backup_datafile.

DEV> select count(*),fhscn,fhrba_seq  from x$kcvfh group by fhscn,fhrba_seq;

  COUNT(*) FHSCN             FHRBA_SEQ
---------- ---------------- ----------
         6 8846902                 411

---- Choose the greatest of either the absolute_fuzzy_change# or checkpoint_change# for your backupset.

DEV> select FILE#,ABSOLUTE_FUZZY_CHANGE#,CHECKPOINT_CHANGE#, CHECKPOINT_TIME,COMPLETION_TIME  from v$backup_datafile where file#=1;

     FILE# ABSOLUTE_FUZZY_CHANGE# CHECKPOINT_CHANGE# CHECKPOINT_TIME       COMPLETION_TIME
---------- ---------------------- ------------------ -------------------- --------------------
         1                      0            8846902 11-feb-2016 15:03:17  11-feb-2016 18:04:38
         1                      0            8922427 13-feb-2016 05:49:59  13-feb-2016 06:00:54        
         1                      0            9754232 22-feb-2016 09:43:44  22-feb-2016 09:44:50
         1                      0            9769121 22-feb-2016 15:31:48  22-feb-2016 15:32:15
         1                      0            9774236 22-feb-2016 17:34:01  22-feb-2016 17:34:44----------------
         1                      0            9662375 24-feb-2016 17:05:07  24-feb-2016 17:05:50
         
OR  
 select max(absolute_fuzzy_change#) fuzz#, max(checkpoint_change#) chkpnt# from
			(select file#, completion_time, checkpoint_change#, absolute_fuzzy_change# from v$backup_datafile
			where incremental_level = 0
			and trunc(completion_time) = to_date('22-FEB-2016','DD-MON-YYYY') 
			and file# <> 0
			order by completion_time desc
		        );         
         OR
         select sequence#, to_date(first_time,'DD-MON-YYYY HH24:MI:SS') first_time, 
						  first_change#, 
						  to_date(next_time,'DD-MON-YYYY HH24:MI:SS') next_time, 
						  next_change# from v$archived_log
			 where completion_time between to_date('23-FEB-2016','DD-MON-YYYY')  and Sysdate
			 ;
         
SEQUENCE# FIRST_TIME           FIRST_CHANGE# NEXT_TIME            NEXT_CHANGE#
---------- -------------------- ------------- -------------------- ------------
        33 22-feb-2016 17:36:24       9774320 23-feb-2016 01:20:00      9793934
        34 23-feb-2016 01:20:00       9793934 23-feb-2016 03:06:05      9809084 -----------restore target date (17h)
        34 23-feb-2016 01:20:00       9793934 23-feb-2016 03:06:05      9809084 ---(displayed even after recovery open resetlogs)
        1  24-feb-2016 09:19:43       9569805 24-feb-2016 09:25:59      9583721------------
                       ==============LOGMINER=======================
			BEGIN
			    DBMS_LOGMNR.add_logfile (
			    options     => DBMS_LOGMNR.new,
			    logfilename => '/tmp/a55050.arc');
			END;
			/

			BEGIN
			  DBMS_LOGMNR.start_logmnr (
			    starttime => to_date('10-MAR-2010 18:50:00','DD-MON-YYYY HH24:MI:SS'),
			    endtime => to_date('10-MAR-2010 19:05:00','DD-MON-YYYY HH24:MI:SS'),
			    options => Dbms_Logmnr.DDL_Dict_Tracking);
			END;
			/

			=======================================
		 	
		Now Query the log, looking for your errors.
		You can make multiple runs of this, narrowing or expanding your search as needed.
  		
			=======================================
			SELECT scn, to_char(timestamp,'DD-MON-YYYY HH24:MI:SS') timest, operation, sql_redo FROM   v$logmnr_contents
			where scn between  21822207692 and 21822211410
			order by scn;
			=======================================
			
			You can look for, grep, search, find the operation in question.
			Then choose that EXACT SCN to roll forward to.
			You will want to subtract 1 from the result.
			
	Finally:
5) Create your restore script using the found SCN#.

	Once you have chosen the SCN number, the rest is academic:
		RMAN>
			run {
		 	     set until scn=23138974759;
			     restore database;
			     recover database;
			}
		

        
SQL> Select hxfil FileNo, HXONS OnlineStatus, FHSTA status, FHSCN SCN, FHTHR Thread,
       FHRBA_SEQ Sequence, FHTNM TABLESPACE_NAME  from x$kcvfhall ;     
         
    FILENO ONLINESTATUS     STATUS SCN                  THREAD   SEQUENCE TABLESPACE_NAME
---------- ------------ ---------- ---------------- ---------- ---------- ------------------------------
         1            1       8192 8846902                   1        411 SYSTEM
         2            1          0 8846902                   1        411 UNDOTBS1
         3            1          0 8846902                   1        411 SYSAUX
         4            1          0 8846902                   1        411 USERS
         5            1          0 8846902                   1        411 GRH
         6            1          0 8846902                   1        411 GRHI


2) channel ORA_DISK_3 disabled, job failed on it will be run on another channel

RMAN-00571: ===========================================================
RMAN-00569: =============== ERROR MESSAGE STACK FOLLOWS ===============
RMAN-00571: ===========================================================
RMAN-03009: failure of backup command on ORA_DISK_4 channel at 02/24/2016 12:05:25
ORA-19643: datafile 5: incremental-start SCN is too recent
ORA-19640: datafile checkpoint is SCN 9633080 time 02/24/2016 12:05:24




select to_char(start_time, 'dd-mon-yyyy@hh24:mi:ss') "Date", status, operation
 from v$rman_status where operation in ('BACKUP','RESTORE','CONTROL FILE AND SPFILE AUTOBACK') 
 and start_time > sysdate -1 order by start_time;
Date                          STATUS                  OPERATION
----------------------------- ----------------------- ---------------------------------
13-feb-2016@01:57:04          FAILED                  RESTORE
13-feb-2016@05:59:26          COMPLETED               BACKUP 
 	

Linux:      
------
Simple RMAN script to take cold database backup:

- For taking RMAN cold database backup, Database should be in mount status, Which can be noticed from below scipt.

mkdir -p /BACKUP/PROD
mkdir -p /BACKUP/PROD/log

$cold_backup.sh
export ORACLE_HOME=/u01/app/oracle/product/11.2.0
export ORACLE_SID=PROD
export PATH=$ORACLE_HOME/bin:$PATH
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:$LD_LIBRARY_PATH
rman target / log=/BACKUP/PROD/log/PROD`date +%d%m%Y`.log <<EOF
sql ‘alter system checkpoint’;
shutdown immediate;
startup mount;
sql “create pfile=”/BACKUP/PROD/pfile`date +%d%m%Y`.ora” from spfile”;
RUN {
ALLOCATE CHANNEL disk1 DEVICE TYPE DISK FORMAT ‘/BACKUP/PROD/%U’;
ALLOCATE CHANNEL disk2 DEVICE TYPE DISK FORMAT ‘/BACKUP/PROD/%U’;
ALLOCATE CHANNEL disk3 DEVICE TYPE DISK FORMAT ‘/BACKUP/PROD/%U’;
BACKUP AS COMPRESSED BACKUPSET DATABASE;
BACKUP CURRENT CONTROLFILE FORMAT ‘/BACKUP/PROD/cntrl_%s_%p_%t’;
RELEASE CHANNEL disk1;
RELEASE CHANNEL disk2;
RELEASE CHANNEL disk3;
}
script execution:
./cold_backup.sh
Simple RMAN script to RESTORE DATABASE:

Make sure that rman backup is mounted on target system and necessary directories configured same as source system
$restore.sh
run
{
startup pfile=’/BACKUP/PROD/pfilexxxxxxx.ora’ nomount;
restore controlfile from ‘/BACKUP/PROD/cntrl_xxxxxxx’;
alter database mount;
restore database;
alter database open resetlogs;
}
script execution:
$rman target /
rman>@restore.sh
Finally change the database name using nid (DBNEWID) utility.

================================================================
                   CHECK   SIZES 
================================================================
 select start_time,end_time,input_bytes_display,output_bytes_display,status from v$rman_backup_job_details order by 1;

START_TIME           END_TIME                    OUTPUT_BYTES_DISPLAY STATUS
-------------------- -------------------- -------------------- -------------------- -----------------------
11-feb-2016 18:03:36 12-feb-2016 15:08:51    11.88G               11.40G            COMPLETED
12-feb-2016 15:44:30 12-feb-2016 16:27:31    47.03M               47.89M            COMPLETED
13-feb-2016 05:50:12 13-feb-2016 05:50:16     0.00K                0.00K            FAILED
13-feb-2016 05:59:26 13-feb-2016 15:34:25    11.90G               11.41G            COMPLETED
13-feb-2016 18:44:38 13-feb-2016 18:50:27    11.86G               11.38G            COMPLETED
13-feb-2016 19:06:54 13-feb-2016 19:10:15    11.86G                1.89G            COMPLETED     
     
    
SQL> SELECT SEQUENCE#,FIRST_TIME, NEXT_TIME
 FROM V$ARCHIVED_LOG
 WHERE SEQUENCE#='27';
 
  SEQUENCE# FIRST_TI NEXT_TIM
---------- -------- --------
        27 16-02-22 16-02-22

SQL> archive log list;
 Database log mode              Archive Mode
 Automatic archival             Enabled
 Archive destination            +FRA
 Oldest online log sequence     551
 Next log sequence to archive   553
 Current log sequence           553
 
SQL>show parameter db_recovery_file_dest;
NAME                                 Type   VALUE
------------------------------------ ------ ------------------------------
db_recovery_file_dest                string +FRA
db_recovery_file_dest_size           big in 20G
                                     teger
SQL> SELECT * FROM V$RECOVERY_FILE_DEST;
 
 SQL> Select max(sequence#) from v$log_history;
 SQL> Select max(sequence#) current_log  from v$log;
 SQL> Select max(sequence#) from v$archived_log;   
    
    
    
    
     Archives size:
     -------------------
     COLUMN DUMMY NOPRINT
     compute sum of 2 on dummy
     BREAK ON DUMMY
     
    SQL> SELECT TO_CHAR(FIRST_TIME,'DD-MON-YYYY') "Date", To_char(sum(bytes/(1024*1024)),'99,999.99') "Logs (MB)"
     From (select unique blocks * block_size Bytes,thread#,sequence#,resetlogs_change#,first_time 
           FROM  v$archived_log)
     GROUP by FIRST_TIME
     ORDER by 1 desc ;      
     
     Select TO_CHAR(MIN(FIRST_TIME),'DD-MON-YYYY') MinDate,TO_CHAR(MAX(FIRST_TIME),'DD-MON-YYYY') maxDate,min(sequence#) min_SEQ, max(sequence#) max_SEQ, sum(blocks * block_size)/(1024*1024) MBytes 
           FROM  v$archived_log;
     
     
     BACKUP size Storred in FRA
     ---------------------------
     SQL> SELECT END_TIME,TO_CHAR(output_bytes/(1024*1024),'999,999,999,999.99')"BACKUP SIZE(MB)"
     FROM V$RMAN_BACKUP_JOB_DETAILS
     WHERE INPUT_TYPE='DB_INCR'
     Order by END_TIME desc;
     
     Database size 
     -----------------
     Select to_char(sum(bytes/(1024*1024)),'999,999,999,999.99') "DATABASE SIZE (MB)"
     From v$datafile;
    
     Log size:
     -----------------
     Select to_char(sum(bytes/(1024*1024)),'999,999,999,999.99') "Online logs size (MB)"
     From
     v$log;
     
     Control files size
     ------------------
     Select to_char(block_size * File_size_blks/(1024*1024),'999,999,999,999.99')"Control file size"
     FROM V$controlfile
     WHERE rownum=1;
     
     FRA space usage 
     ----------------
     SQL> SELECT substr(NAME,1,25) "FRA Location", SPACE_LIMIT/(1204*1024) "Limit (MB)",
                  SPACE_USED/(1204*1024) "Used (MB)", 
                  SPACE_RECLAIMABLE/(1204*1024)"Reclaimable(MB)",
                  Number_of_files "File Count"
          FROM   V$recovery_file_dest;        
          
          
     Check the whole space in the FRA :
     ----------------------------------
     SQL> SELECT * FROM V$FLASH_RECOVERY_AREA_USAGE; 
     
     
     the below reset the discrepancy between V$FLASH_RECOVERY_AREA_USAGE and V$RECOVERY_FILE_DEST.

     SQL> Alter session set events 'immediate trace name kra_options level 1';
          Execute dbms_backup_restore.refreshagedfiles;

              
 3- PURGE     
                                                                             
 run {
  backup archivelog all not backed up 2 times;
  delete noprompt archivelog all backed up 2 times to device type disk;
  }
  
   run {
  delete noprompt archivelog all completed before 'sysdate -5';
     }                                                                         
                                                                      



list of backups 
RMAN11_D
RMAN11_T
RMAN11_P
RMAN11_A



check rman media failure 
ORA-07445: exception encountered: core dump [PC:0x0] [SIGILL] [ADDR:0x0] [PC:0x0] [Illegal opcode] []
ORA-19502: write error on file "/APPL/ORACLE/ABGENA/admin/backup/ARCHIVEc-2405942065-20130320-03", block number 1 (block size=16384)
ORA-27030: skgfwrt: sbtwrite2 returned error
ORA-19511: Error received from media manager layer, error text:
   ANS1235E (RC-72)  An unknown system error has occurred from which TSM cannot recover.
oracle@sbeaaeak(ABGENA)[/ING/TIVOLI/TSM/rman] more sbeaaeak.tdpoerror.err.20130321

#####See if a database is registered 
1- select * from RMAN11_A.rc_database;

1-  select db_name, input_type, status, min(start_time), max(start_time), round(avg((end_time-start_time)*1440),2) "minutes",AUTOBACKUP_COUNT,AUTOBACKUP_DONE
    from RMAN11_P.RC_RMAN_BACKUP_JOB_DETAILS
    where start_time > trunc(sysdate)-7
    group by db_name, input_type, status,AUTOBACKUP_COUNT,AUTOBACKUP_DONE
   order by db_name;


crosscheck archivelog all;

1.7	Manual backup execution

Retrieve the backup configuration file
#ls -l /APPL/TIVOLI/TSM/scripts/*_R*${ORACLE_SID}*
e.g.  /APPL/TIVOLI/TSM/scripts/(logical_host)_RCAE(OSID).bkpprm
And start the backup script
# /ING/TIVOLI/TSM/scripts/TSM_rman_backup.ksh $(basename /APPL/TIVOLI/TSM/scripts/*_RCAE${ORACLE_SID}*)   (show_cmds optional)

1.8	Manual archive backup execution

# /ING/TIVOLI/TSM/scripts/TSM_rman_backup.ksh $(basename /APPL/TIVOLI/TSM/scripts/*_RCAE${ORACLE_SID}*) override arch



ls -ltr /APPL/ORACLE/$ORACLE_SID/admin/backup   (to see channel used in the backup )

2 Restore
2.1	Example of restore/recover
RMAN> shutdown database;
RMAN> startup mount;
RMAN> run {
	 allocate channel TDPO0 type 'SBT_TAPE' parms 'ENV=(TDPO_OPTFILE=/ING/TIVOLI/TSM/dsmconfig/TSM_{hostname}_RCAE{OSID}.tdpo.opt)';
	 allocate channel TDPO1 type 'SBT_TAPE' parms 'ENV=(TDPO_OPTFILE=/ING/TIVOLI/TSM/dsmconfig/TSM_{hostname}_RCAE{OSID}.tdpo.opt)';
	 restore database;
	 recover database;
	}
RMAN> alter database open;


2.3	Loss of all controlfiles
Restart database into nomount mode.
Set RMAN environment for the database.
Start rman
Cd /APPL/ORACLE/ABCBSA/admin/cfg
Export TNS_ADMIN=$PWD
#rman target /@$ORACLE_SID catalog /@catalog
RMAN> run {
 allocate channel TDPO0 type 'SBT_TAPE' parms 'ENV=(TDPO_OPTFILE=/APPL/TIVOLI/TSM/dsmconfig/TSM_{hostname}_RFAR{OSID}.tdpo.opt)';
 restore controlfile;
 }
RMAN> alter database mount;
RMAN> recover database;
RMAN> alter database open resetlogs;
Restart database.



2.4	Tablespace point in time recovery

Restart database into mount mode.
Set RMAN environment for the database.
Start RMAN
rman target /@$ORACLE_SID catalog /@catalog
RMAN> run {
 allocate channel TDPO0 type 'SBT_TAPE' parms 'ENV=(TDPO_OPTFILE=/APPL/TIVOLI/TSM/dsmconfig/TSM_{hostname}_RFAR{OSID}.tdpo.opt)';
 restore tablespace users until time 'sysdate-1';
 recover database;
 }
RMAN> alter database open;

2.5	Restoring the database parameter file

Remove the symbolic link from $ORACLE_HOME/dbs directory for the database parameter file.
Set RMAN environment for the database.
Start rman
#rman target /@$ORACLE_SID catalog /@catalog
RMAN> startup nomount pfile=/APPL/ORACLE/OSID/admin/cfg/initOSID.ora
RMAN> restore spfile;
Recreate the symbolic link to $ORACLE_HOME/dbs
And restart the database.



*********************ARCHIVE FILESYSTEM FULL:************************************

1)Cook book script archive logs Or 

2)manual execution: ll /ING/TIVOLI/TSM/dsmconfig/TSM_*.tdpo.opt        to find parameter files
then  cd cfg
export TNS_ADMIN=$PWD
rman target / catalog /@catalog

run 
{
allocate channel TDPO0 type 'SBT_TAPE' parms 'ENV=(TDPO_OPTFILE=/ING/TIVOLI/TSM/dsmconfig/TSM_sbeaaeat_RCAEABFARA.tdpo.opt)';
allocate channel TDPO1 type 'SBT_TAPE' parms 'ENV=(TDPO_OPTFILE=/ING/TIVOLI/TSM/dsmconfig/TSM_sbeaaeat_RCAEABFARA.tdpo.opt)';
backup archivelog all;
backup archivelog all delete input;
}
3)	If mcr zipped files:
run 
{
allocate channel TDPO0 type 'SBT_TAPE' parms 'ENV=(TDPO_OPTFILE=/ING/TIVOLI/TSM/dsmconfig/TSM_sbeaaeat_RCAEABFARA.tdpo.opt)';
allocate channel TDPO1 type 'SBT_TAPE' parms 'ENV=(TDPO_OPTFILE=/ING/TIVOLI/TSM/dsmconfig/TSM_sbeaaeat_RCAEABFARA.tdpo.opt)';
backup archivelog like '/APPL/ORACLE/ABFARA/arch/ABFARA_1_790604477_5%3.arc' delete input ;
}

Restore Archive logs

RMAN> LIST BACKUP OF ARCHIVELOG FROM TIME='28-JUN-2013' UNTIL TIME='28-JUN-2013';

RUN{  
 allocate channel TDPO0 type 'SBT_TAPE' parms 'ENV=(TDPO_OPTFILE=/APPL/TIVOLI/TSM/dsmconfig/AGINFAARC.tdpo.opt)';                                         
  SET ARCHIVELOG DESTINATION TO '/APPL/ORACLE/AGINFA/arch_cdc';
  RESTORE ARCHIVELOG FROM SEQUENCE 1727;
}      




LOGS: Tivoli execution /ING/TIVOLI/TSM/log
            Manual execution : cd backup of the script from the cookbook
	Ls *$ORACLE_SID*

-------------------------------------------LIST BACKUP


LIST DB_UNIQUE_NAME ALL 

 LIST DB_UNIQUE_NAME OF DATABASE [['] database_name [']]

 LIST [EXPIRED]
     {archivelogRecordSpecifier
       [ { {maintQualifier | RECOVERABLE [untilClause} }…] [forDbUniqueNameOption]

 LIST [EXPIRED]
     {BACKUP [OF listObjectList] [BY BACKUP] [VERBOSE] 
       [ { {maintQualifier | RECOVERABLE [untilClause} }…] [forDbUniqueNameOption]

 LIST [EXPIRED]
     {BACKUP [OF listObjectList] SUMMARY
       [ { {maintQualifier | RECOVERABLE [untilClause} }…] [forDbUniqueNameOption]

 LIST [EXPIRED]
     {BACKUP [OF listObjectList] BY { BACKUP SUMMARY | FILE }
       [ { {maintQualifier | RECOVERABLE [untilClause} }…] [forDbUniqueNameOption]

 LIST [EXPIRED]
     {COPY [OF listObjectList] 
       [ { {maintQualifier | RECOVERABLE [untilClause} }…] [forDbUniqueNameOption]

 LIST [EXPIRED] recordSpec [forDbUniqueNameOption];

 LIST FAILURE [ {ALL | CRITICAL | HIGH | LOW | failureNumber [, failureNumber]…}
    [EXCLUDE FAILURE failureNumber [, failureNumber]…] [DETAIL]

 LIST FAILURE [CLOSED] [ {ALL | CRITICAL | HIGH | LOW | failureNumber} ]
    [EXCLUDE FAILURE failureNumber [, failureNumber]…] [DETAIL]

 LIST INCARNATION [OF DATABASE [['] database_name [']]]

 LIST RESTORE POINT restore_point_name [forDbUniqueNameOption]

 LIST RESTORE POINT ALL [forDbUniqueNameOption] 
       
 LIST ALL SCRIPT NAMES

 LIST GLOBAL SCRIPT NAMES


forDbUniqueNameOption::=
  FOR DB_UNIQUE_NAME ALL
  FOR DB_UNIQUE_NAME 'db_unique_name'

 listObjectList::=
   [ DATAFILE datafileSpec [, datafileSpec]… 
   | TABLESPACE ['] tablespace_name ['] [, ['] tablespace_name [']]…
   | archivelogRecordSpecifier 
   | DATABASE [SKIP TABLESPACE ['] tablespace_name ['] 
     [, ['] tablespace_name [']]…] 
   | CONTROLFILE
   | SPFILE
   ]…

 listBackupOption::=
   [ [BY BACKUP] [VERBOSE]
   | SUMMARY
   | BY { BACKUP SUMMARY | FILE }
   ] 


ARCHIVELOG 
     {   ALL 
       | LIKE 'string_pattern' 
       | archlogRange [LIKE 'string_pattern' [THREAD [=] integer]]
     }
 
   archlogRange::=
    {
      {  FROM TIME  [=] 'date_string'
       | UNTIL TIME  [=] 'date_string'
       | TIME BETWEEN 'date_string' AND 'date_string' 
       | FROM TIME [=] 'date_string' UNTIL TIME [=]'date_string' 
       | UNTIL SCN [=] integer
       | SCN BETWEEN integer AND integer 
       | FROM SCN [=] integer [UNTIL SCN [=] integer]
      }
     [THREAD [=] integer]
       | {  UNTIL SEQUENCE [=] integer
          | FROM SEQUENCE [=] integer [UNTIL SEQUENCE [=] integer] 
          | SEQUENCE [BETWEEN integer AND] integer
         }
      [THREAD [=] integer]
   }

untilClause

{ UNTIL TIME [=] 'date_string'
| UNTIL SCN [=] integer
| UNTIL SEQUENCE [=] integer THREAD [=] integer
}



===========================================
backup spfile
=============


 set echo off
 set feedback off
 set termout off
 set heading off
 declare
   v_count   number;
   v_baknum  number;
   v_sid     varchar2(20);
   v_pfile   varchar2(20);
   v_spfile  varchar2(20);
   v_stmt    varchar2(200);
 begin
   v_baknum:=mod(to_number(to_char(sysdate,'d')),7);
   select name into v_sid from v\$database;
   v_pfile:='init' || v_sid || '.bak.' || v_baknum;
   v_spfile:='spfile' || v_sid || '.bak.' || v_baknum;
   --does spfile exist, if only pfile then no backup made
   select count(1) into v_count from v\$parameter where name = 'spfile' and value is not null;
   if v_count = 1 then
     -- create a pfile from the "current" spfile
     v_stmt:='create pfile=''' || v_pfile || ''' from spfile';
     execute immediate v_stmt;
     -- crate a spfile from the newly created pfile (otherwise will try to use standard location which might not exist)
     v_stmt:='create spfile=''' || v_spfile || ''' from pfile=''' || v_pfile || '''';
     execute immediate v_stmt;
   end if;
end;
/
ALTER DATABASE BACKUP CONTROLFILE TO TRACE AS FILENAME 'C:\oracle\product\10.2.0\flash_recovery_area\Backup';
==============================


select decode(BACKUP_TYPE, 'L', 'ARCH', 'D', 'DB', 'I', 'INC',
'Unknown type='||BACKUP_TYPE) TYPE,
to_char(a.start_time, 'DDMON HH24:MI') start_time,
to_char(a.elapsed_seconds/60, '99.9')||' Min' DURATION,
substr(handle, -35) handle,
nvl(d.file#, l.sequence#) file#, nvl(d.blocks, l.blocks) blocks
from SYS.V_$BACKUP_SET a, SYS.V_$BACKUP_PIECE b,
SYS.V_$BACKUP_DATAFILE d, SYS.V_$BACKUP_REDOLOG l
where a.start_time between sysdate-1 and sysdate
and a.SET_STAMP = b.SET_STAMP
and a.SET_STAMP = d.SET_STAMP(+)
and a.SET_STAMP = l.SET_STAMP(+)
order by start_time, file#
/	

Querying RC_BACKUP_FILES : for information about all backups of any database registered in the recovery catalog.
must run this before :

SQL> CALL DBMS_RCVMAN.SETDATABASE(null,null,null,DBID);



select * from v$backup_datafile
where file# <> 0 and
(set_stamp,set_count) in (
select set_stamp,set_count from
v$backup_piece where status = ‘A’
minus
select set_stamp,set_count from
v$backup_piece where status <> ‘A’); 



RMAN> CROSSCHECK ARCHIVELOG FROM SCN $START_SCN;
RMAN> CROSSCHECK BACKUP OF ARCHIVELOG FROM SCN $START_SCN;

--------------------------------------
1. Issue the following RMAN commands:
--------------------------------------
CROSSCHECK BACKUP OF DATABASE COMPLETED AFTER “SYSDATE-15”;
CROSSCHECK BACKUP OF CONTROLFILE COMPLETED AFTER “SYSDATE-15”;
CROSSCHECK BACKUP OF SPFILE COMPLETED AFTER “SYSDATE-15”;
CROSSCHECK COPY  OF DATABASE COMPLETED AFTER “SYSDATE-15”;
CROSSCHECK COPY  OF CONTROLFILE COMPLETED AFTER “SYSDATE-15”;
CROSSCHECK COPY  OF SPFILE COMPLETED AFTER “SYSDATE-15”;

==========================================================================
              Recommendations for Backup and Recovery
==========================================================================
Views :
------
V$BACKUP_ARCHIVELOG_DETAILS
V$BACKUP_DATAFILE_DETAILS
V$BACKUP_CONTROLFILE_DETAILS
V$BACKUP_SPFILE_DETAILS

--------
RMAN : completedTimeSpec Syntax:
----
COMPLETED AFTER [=] 'date_string'
COMPLETED BETWEEN 'date_string' AND 'date_string'
COMPLETED BEFORE [=] 'date_string'

col RD_FIRST_CHANGE for a15
col CREATE_CKP for a10
col BACKUP_TYPE  for  a12
col FILE_TYPE    for a15
col DF_TABLESPACE for a12
col BS_TAG        for a20
col SEQUENCE    for a10
col CHANGE_CKP  for a10
COL FIRST_CHANGE FOR A10
COL INCR FOR A10                                                                                                                                                        
SQL> SELECT BACKUP_TYPE,FILE_TYPE,DF_TABLESPACE,BS_INCR_TYPE "INCR",BS_COMPLETION_TIME,BS_TAG,nvl(trim(DF_CREATION_CHANGE#),0) "CREATE_CKP" ,
 nvl(ltrim(DF_CHECKPOINT_CHANGE#),0) "CHANGE_CKP",nvl(rtrim(RL_SEQUENCE#),0) SEQUENCE,nvl(ltrim(RL_FIRST_CHANGE#),0) "FIRST_CHANGE",COMPRESSED,status from  V$BACKUP_FILES ;

 
 Select b.*,r.start_time,r.end_time
from v$backup_datafile_details b
join v$rman_status r
on (b.session_recid=r.recid and
b.session_stamp = r.stamp);


- Use Recovery Manager to Back Up Database Files
- Understand When to Use Backups
- Use an RMAN Recovery Catalog
- Use the Autobackup Feature for the Control File and SPFILE
- Use Incrementally Updated Backups to Reduce Restoration Time
- Enable Block Change Tracking (BCT)to Reduce Backup Time (enhance performance of the incremental backups)

   SQL> alter database enable block change tracking using file 'C:\oradata\snapdb\block_change_tracking.dbf';
   SQL> SELECT status from v$block_change_tracking;
   disable : ALTER DATABASE DISABLE BLOCK CHANGE TRACKING;


- Create Database Backups on Disk in the Flash Recovery Area
- Create Tape Backups from the Flash Recovery Area
- Determine Retention Policy and Backup Frequency
- Configure the Size of the Flash Recovery Area Properly
- In a Data Guard Environment, Back Up to the Flash Recovery Area on All Sites
- During Backups, Use the Target Database Control File as the RMAN Repository
- Regularly Check Database Files for Corruption
- Periodically Test Recovery Procedures
- Back Up the OCR to Tape or Offsite
