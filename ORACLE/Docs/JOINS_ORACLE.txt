                                                        ============================================================================
                                                        Nested loops, Hash join and Sort Merge joins – difference?  
                                                        ============================================================================      
      
  
  -- INTRODUCTION ---
     The 'driving' table is the table we will join FROM -- that is JOIN TO other tables.  
     For example, lets say you have the query:    
          SELECT * from EMP, DEPT where emp.deptno = dept.deptno;
       
   Execution Plan
   ----------------------------------------------------------
    0      SELECT STATEMENT Optimizer=CHOOSE
    1    0   TABLE ACCESS (BY INDEX ROWID) OF 'EMP'
    2    1     NESTED LOOPS
    3    2       TABLE ACCESS (FULL) OF 'DEPT'
    4    2       INDEX (RANGE SCAN) OF 'TEMP_IDX' (NON-UNIQUE)

    In this case the driving table might be DEPT, we would fetch rows from DEPT in a full scan and then find the rows in EMP that match. DEPT is the driving table.
    Table sizes, cardinality of column values, and other things can affect the choice of a driving table (eg: HINTS).
    When using CBO order of tables is not relevant (unless you hint it to be). Statistics and data dictionary are used to determine which table is best to be driving table. 
     ex: 
      for x in ( select * from dept ) /* table access (full) dept -- driving table */
        loop
           do an index lookup to find matching rows in emp
           for each row found in that index lookup
                 output data
           end loop
        end loop 
              
      The optimizer will try out the sensible join orders and based on estimated cardinalities - determine which one results in the fewest amount of IO's/CPU being used. That is the plan it would choose. 
      1) the optimizer will look at the joins and the predicates - try to decide which row source should go first in order to find the minimum set of rows to start with.
      run an explain plan and see what the optimizer says :) It'll show you the tables and the order in which they would be accessed.  
      
  I-    Nested loop (loop over loop)
      
   In this algorithm, an outer loop is formed which consists of few entries and then for each entry, and inner loop is processed.
      
   Ex:
   
   Select tab1.*, tab2.* from tabl, tab2 where tabl.col1=tab2.col2;
   
   It is processed like:
   
   For i in (select * from tab1) loop
   For j in (select * from tab2 where col2=i.col1) loop
   Display results;
   End loop;
   End loop;
   
   The Steps involved in doing nested loop are:
   
   a) Identify outer (driving) table
   
   b) Assign inner (driven) table to outer table.
   
   c) For every row of outer table, access the rows of inner table.
    rule based optimizer tend to pick a driving table from the end of the FROM list
   ----------------------------------------
   In execution plan it is seen like this:
    =====================================  
    NESTED LOOPS
     outer_loop
     inner_loop
   =======================================
   When optimizer uses nested loops?
   
   Optimizer uses nested loop when we are joining tables containing small number of rows with an efficient driving condition. It is important to have an index on column of inner join table
   as this table is probed every time for a new value from outer table.
   
   Optimizer may not use nested loop in case:
   
   No of rows of both the table is quite high
   Inner query always results in same set of records
   The access path of inner table is independent of data coming from outer table.
   Note: You will see more use of nested loop when using FIRST_ROWS optimizer mode as it works on model of showing instantaneous results to user as they are fetched. There is no need for 
   selecting caching any data before it is returned to user. In case of hash join it is needed and is explained below.

 II-  Hash join

  Hash joins are used when the joining large tables. The optimizer uses smaller of the 2 tables to build a hash table in memory and the scans the large tables and compares the hash value 
  (of rows from large table) with this hash table to find the joined rows.
  
  The algorithm of hash join is divided in two parts
  
  Build a in-memory hash table on smaller of the two tables.
  Probe this hash table with hash value for each row second table
  In simpler terms it works like
  
  Build phase
  
  For each row RW1 in small (left/build) table loop
  Calculate hash value on RW1 join key
  Insert RW1 in appropriate hash bucket.
  End loop;
  
  Probe Phase
  
  For each row RW2 in big (right/probe) table loop
  Calculate the hash value on RW2 join key
  For each row RW1 in hash table loop
  If RW1 joins with RW2
  Return RW1, RW2
  End loop;
  End loop;

   When optimizer uses hash join?
   
   Optimizer uses has join while joining big tables or big fraction of small tables.
   
   Unlike nested loop, the output of hash join result is not instantaneous as hash joining is blocked on building up hash table.
   
   Note: You may see more hash joins used with ALL_ROWS optimizer mode, because it works on model of showing results after all the rows of at least one of the tables are hashed in hash table.
   
II- Sort merge join
   
   Sort merge join is used to join two independent data sources. They perform better than nested loop when the volume of data is big in tables but not as good as hash joins in general.
   
   They perform better than hash join when the join condition columns are already sorted or there is no sorting required.
   
   The full operation is done in two parts:
   
   Sort join operation
   get first row RW1 from input1
   get first row RW2 from input2.



III- Merge join operation
   While not at the end of either input loop if RW1 joins with RW2
   get next row R2 from input 2
   return (RW1, RW2)
   else if RW1 < style=""> get next row RW1 from input 1
   else
   get next row RW2 from input 2
   end loop
   
   Note: If the data is already sorted, first step is avoided.
   
   Important point to understand is, unlike nested loop where driven (inner) table is read as many number of times as the input from outer table, in sort merge join each of the tables involved 
   are accessed at most once. So they prove to be better than nested loop when the data set is large.
   
   When optimizer uses Sort merge join?
   
   a) When the join condition is an inequality condition (like <, <=, >=). This is because hash join cannot be used for inequality conditions and if the data set is large, nested loop is definitely 
   not an option.
   
   b) If sorting is anyways required due to some other attribute (other than join) like “order by”, optimizer prefers sort merge join over hash join as it is cheaper.
   
   Note: Sort merge join can be seen with both ALL_ROWS and FIRST_ROWS optimizer hint because it works on a model of first sorting both the data sources and then start returning the results. 
   So if the data set is large and you have FIRST_ROWS as optimizer goal, optimizer may prefer sort merge join over nested loop because of large data. 
   And if you have ALL_ROWS as optimizer goal and if any inequality condition is used the SQL, optimizer may use sort-merge join over hash join.
   
  --------------------------------------statstics
   As of Oracle 10g its possible to set artificial statistics increasing rownum , we can changed plan from "Nested loop" to "Hash join" .we can manipulate the table/index stats to check change in optimizer plan.
   In fact, many change the stats in production to "guarantee" a particular type of plan                                                                    
   -------
   example
   -------                                                                                                                                                                                                                                                                           
   exec dbms_stats.set_table_stats(ownname => 'GRH1', tabname => 'P_DATEPAIE', numrows => 1000000, numblks => 10000, avgrlen => 124);                                                                                                                                           
                                                                                                                                                                                                                                                                           
   PL/SQL procedure successfully completed.                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                           
   SQL> exec dbms_stats.set_index_stats(ownname => 'GRH1', indname => 'IDX_DATEPAIE_CALENDRIER', numrows => 1000000, numlblks => 1000);                                                                                                                                                   
                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                           
   PL/SQL procedure successfully completed.                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                           
   SQL>scott>exec dbms_stats.set_table_stats(ownname => 'GRH1', tabname => 'R_EMPLOYE', numrows => 1000000,numblks => 10000 , avgrlen => 124);                                                                                                                                     
                                                                                                                                                                                                                                                                           
                                                                                                                                                                                                                                                                           
   PL/SQL procedure successfully completed.                                                                                                                                                                                                                                   
                                                                                                                                                                                                                                                                           
   SQL> SELECT DP.DATE_DEBUT, DP.DATE_FIN       ---avant après                                                                                                                                                                                                                    
        FROM P_DATEPAIE DP, R_EMPLOYE E                     
        WHERE DP.ID_P_CALENDRIERPAIE = E.ID_P_CALENDRIERPAIE
        AND E.ID_R_EMPLOYE = 243983717                      
        AND DP.DATE_DEBUT = (                               
        SELECT MIN(D.DATE_DEBUT)                            
        FROM P_DATEPAIE D, R_EMPLOYE EE                     
        WHERE D.PAIE_FERMEE = 0                             
        AND D.ID_P_CALENDRIERPAIE = EE.ID_P_CALENDRIERPAIE  
        AND EE.ID_R_EMPLOYE = 243983717)  ;
        
    select count(*) from GRH1.R_EMPLOYE sample block (20);   
    
    
    
   VI- SORT AGGREGATE SORT OPERATION
   
      SELECT count(*) from some_table; 
       is just a special case of => :  SELECT col_a,count(*) from some_table group by col_a;
      ----------
      In the first case, the algorithm is the same, except there's only one group for which the count is happening. So, Oracle still does the SORT AGGREGATE operation. 
       the programmers simply haven't got around to writing a bit of code that says: "if the number of columns we aggregate on is zero then append 'NOSORT' to the operation text". 
       