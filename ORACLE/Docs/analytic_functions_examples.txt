*******
HINTS:
******
Specifying a Query Block in a Hint : You can specify an optional query block name in many hints to specify the query block to which the hint applies.
Use the QB_NAME hint to define a name for a query block
SELECT /*+ QB_NAME(qb) FULL(@qb e) */ employee_id, last_name
  FROM employees e
  WHERE last_name = 'Smith';
  
  -------------------
    HIEARCHICHAL QUERY
  --------------------
There are 2 components to is: 

1- "start with" -- this identifies all LEVEL=1 nodes in the tree 

2 -"connect by" -- describes how to walk from the parent nodes above to their children and their childrens children.
  CONNECT BY PRIOR EMPNO = /* current */ MGR
  
  SQL> select lpad ename, empno, mgr 
2 from emp 
3 START WITH MGR IS NULL  --- LEVEL=1 nodes
4 CONNECT BY PRIOR EMPNO = MGR  ---  all of the PRIOR records (the start with at first) and find all records such that the MGR column equals their EMPNO


- CONNECT BY LEVEL 
Create table a ( id number );
insert into a values (1);
insert into a values (2);
insert into a values (3);

Level <= 2, then you get each level : 1 time (for level 1) + N times (where N is the number of records in the table) level 2= 12
So for 3 records:
ID | LVL 
---+-----
 1 |  1 
 1 |  2 
 1 |  2 
 1 |  2 
 2 |  1 
 2 |  2 
 2 |  2 
 2 |  2 
 3 |  1 
 3 |  2 
 3 |  2 
 3 |  2 
Lvl 1: 3 record (all having level 1)
Lvl 2: 3 records having level 1 + 3*3 records having level 2 = 12
Lvl 3: lvl1 (3) + lvl2 (3*3) + lvl 3 3*(3*3) = 39 (indeed, 13 records each)
Lvl N: lvl1 (3) + lvl2 (3*3) + lvl 3 3*(3*3)....+lvl N 3*(lvl N-1) = x
***********************************************************************************************************                                                                  
Analytic functions by Example                                                                                                                                                
**********************************************************************************************************
table contains hierarchical data:                                                                                                                         
DROP TABLE tab1 PURGE;                                                                                                                                    
                                                                                                                                                          
CREATE TABLE tab1 (                                                                                                                                       
  id        NUMBER,                                                                                                                                       
  parent_id NUMBER,                                                                                                                                       
  CONSTRAINT tab1_pk PRIMARY KEY (id),                                                                                                                    
  CONSTRAINT tab1_tab1_fk FOREIGN KEY (parent_id) REFERENCES tab1(id)                                                                                     
);                                                                                                                                                        
                                                                                                                                                          
CREATE INDEX tab1_parent_id_idx ON tab1(parent_id);                                                                                                       
                                                                                                                                                          
INSERT INTO tab1 VALUES (1, NULL);                                                                                                                        
INSERT INTO tab1 VALUES (2, 1);                                                                                                                           
INSERT INTO tab1 VALUES (3, 2);                                                                                                                           
INSERT INTO tab1 VALUES (4, 2);                                                                                                                           
INSERT INTO tab1 VALUES (5, 4);                                                                                                                           
INSERT INTO tab1 VALUES (6, 4);                                                                                                                           
INSERT INTO tab1 VALUES (7, 1);                                                                                                                           
INSERT INTO tab1 VALUES (8, 7);                                                                                                                           
INSERT INTO tab1 VALUES (9, 1);                                                                                                                           
INSERT INTO tab1 VALUES (10, 9);                                                                                                                          
INSERT INTO tab1 VALUES (11, 10);                                                                                                                         
INSERT INTO tab1 VALUES (12, 9);                                                                                                                          
COMMIT;                                                                                                                                                   
1- Basic Hierarchical Query                                                                                                                               
                                                                                                                                                          
WITH t1(id, parent_id) AS (                                                                                                                               
  -- Anchor member.                                                                                                                                       
  SELECT id,                                                                                                                                              
         parent_id                                                                                                                                        
  FROM   tab1                                                                                                                                             
  WHERE  parent_id IS NULL                                                                                                                                
  UNION ALL                                                                                                                                               
  -- Recursive member.                                                                                                                                    
  SELECT t2.id,                                                                                                                                           
         t2.parent_id                                                                                                                                     
  FROM   tab1 t2, t1                                                                                                                                      
  WHERE  t2.parent_id = t1.id                                                                                                                             
)                                                                                                                                                         
SELECT id,                                                                                                                                                
       parent_id                                                                                                                                          
FROM   t1;                                                                                                                                                
                                                                                                                                                          
result is disordered                                                                                                                                      
=====                                                                                                                                                     
The ordering of the rows is specified using the SEARCH clause, which can use two methods.                                                                 
                                                                                                                                                          
* SEARCH BREADTH FIRST BY : Sibling rows are returned before child rows are processed.                                                                    
* SEARCH DEPTH FIRST BY : Child rows are returned before siblings are processed.                                                                          
------------------------                                                                                                                                  
1- SEARCH BREADTH FIRST                                                                                                                                   
------------------------                                                                                                                                  
WITH t1(id, parent_id) AS (                                                                                                                               
  -- Anchor member.                                                                                                                                       
  SELECT id,                                                                                                                                              
         parent_id                                                                                                                                        
  FROM   tab1                                                                                                                                             
  WHERE  parent_id IS NULL                                                                                                                                
  UNION ALL                                                                                                                                               
  -- Recursive member.                                                                                                                                    
  SELECT t2.id,                                                                                                                                           
         t2.parent_id                                                                                                                                     
  FROM   tab1 t2, t1                                                                                                                                      
  WHERE  t2.parent_id = t1.id                                                                                                                             
)                                                                                                                                                         
SEARCH BREADTH FIRST BY id SET order1                                                                                                                     
SELECT id,                                                                                                                                                
       parent_id                                                                                                                                          
FROM   t1                                                                                                                                                 
ORDER BY order1; 

  ID  PARENT_ID
---- ----------
   1
   2          1
   7          1
   9          1
   3          2
   4          2
   8          7
  10          9
  12          9
   5          4
   6          4
  11         10                                                                                                                                         
------------------------                                                                                                                                  
2- SEARCH DEPTH FIRST                                                                                                                                     
-----------------------                                                                                                                                   
WITH t1(id, parent_id) AS (                                                                                                                               
  -- Anchor member.                                                                                                                                       
  SELECT id,                                                                                                                                              
         parent_id                                                                                                                                        
  FROM   tab1                                                                                                                                             
  WHERE  parent_id IS NULL                                                                                                                                
  UNION ALL                                                                                                                                               
  -- Recursive member.                                                                                                                                    
  SELECT t2.id,                                                                                                                                           
         t2.parent_id                                                                                                                                     
  FROM   tab1 t2, t1                                                                                                                                      
  WHERE  t2.parent_id = t1.id                                                                                                                             
)                                                                                                                                                         
SEARCH DEPTH FIRST BY id SET order1                                                                                                                       
SELECT id,                                                                                                                                                
       parent_id                                                                                                                                          
FROM   t1                                                                                                                                                 
ORDER BY order1; 

 ID     PARENT_ID
------- ----------
      1
      2          1
      3          2
      4          2
      5          4
      6          4
      7          1
      8          7
      9          1
     10          9
     11         10
     12          9
                                                                                                                                      
---------------------------------                                                                                                                         
3- Implement Equivalent of LEVEL                                                                                                                          
----------------------------------                                                                                                                        
COLUMN tree FORMAT A20                                                                                                                                    
                                                                                                                                                          
WITH t1(id, parent_id, lvl) AS (                                                                                                                          
  -- Anchor member.                                                                                                                                       
  SELECT id,                                                                                                                                              
         parent_id,                                                                                                                                       
         1 AS lvl                                                                                                                                         
  FROM   tab1                                                                                                                                             
  WHERE  parent_id IS NULL                                                                                                                                
  UNION ALL                                                                                                                                               
  -- Recursive member.                                                                                                                                    
  SELECT t2.id,                                                                                                                                           
         t2.parent_id,                                                                                                                                    
         lvl+1                                                                                                                                            
  FROM   tab1 t2, t1                                                                                                                                      
  WHERE  t2.parent_id = t1.id                                                                                                                             
)                                                                                                                                                         
SEARCH DEPTH FIRST BY id SET order1                                                                                                                       
SELECT id,                                                                                                                                                
       parent_id,                                                                                                                                         
       RPAD('.', (lvl-1)*2, '.') || id AS tree,                                                                                                           
       lvl                                                                                                                                                
FROM t1                                                                                                                                                   
ORDER BY order1;                                                                                                                                          
       ID  PARENT_ID TREE                        LVL                                                                                                      
---------- ---------- -------------------- ----------                                                                                                     
         1            1                             1                                                                                                     
         2          1 ..2                           2                                                                                                     
         3          2 ....3                         3                                                                                                     
         4          2 ....4                         3                                                                                                     
         5          4 ......5                       4                                                                                                     
         6          4 ......6                       4                                                                                                     
         7          1 ..7                           2                                                                                                     
         8          7 ....8                         3                                                                                                     
         9          1 ..9                           2                                                                                                     
        10          9 ....10                        3                                                                                                     
        11         10 ......11                      4                                                                                                     
        12          9 ....12                        3                                                                                                     
------------------------------------------                                                                                                                
4- Implement Equivalent of CONNECT_BY_ROOT                                                                                                                
-----------------------------------------                                                                                                                 
WITH t1(id, parent_id, lvl, root_id) AS (                                                                                                                 
  -- Anchor member.                                                                                                                                       
  SELECT id,                                                                                                                                              
         parent_id,                                                                                                                                       
         1 AS lvl,                                                                                                                                        
         id AS root_id                                                                                                                                    
  FROM   tab1                                                                                                                                             
  WHERE  parent_id IS NULL                                                                                                                                
  UNION ALL                                                                                                                                               
  -- Recursive member.                                                                                                                                    
  SELECT t2.id,                                                                                                                                           
         t2.parent_id,                                                                                                                                    
         lvl+1,                                                                                                                                           
         t1.root_id                                                                                                                                       
  FROM   tab1 t2, t1                                                                                                                                      
  WHERE  t2.parent_id = t1.id                                                                                                                             
)                                                                                                                                                         
SEARCH DEPTH FIRST BY id SET order1                                                                                                                       
SELECT id,                                                                                                                                                
       parent_id,                                                                                                                                         
       RPAD('.', (lvl-1)*2, '.') || id AS tree,                                                                                                           
       lvl,                                                                                                                                               
       root_id                                                                                                                                            
FROM t1                                                                                                                                                   
ORDER BY order1;                                                                                                                                          
                                                                                                                                                          
       ID  PARENT_ID TREE                        LVL    ROOT_ID                                                                                           
---------- ---------- -------------------- ---------- ----------                                                                                          
         1            1                             1          1                                                                                          
         2          1 ..2                           2          1                                                                                          
         3          2 ....3                         3          1                                                                                          
         4          2 ....4                         3          1                                                                                          
         5          4 ......5                       4          1                                                                                          
         6          4 ......6                       4          1                                                                                          
         7          1 ..7                           2          1                                                                                          
         8          7 ....8                         3          1                                                                                          
         9          1 ..9                           2          1                                                                                          
        10          9 ....10                        3          1                                                                                          
        11         10 ......11                      4          1                                                                                          
        12          9 ....12                        3          1                                                                                          
-----------------------------------------------                                                                                                           
5- Implement Equivalent of SYS_CONNECT_BY_PATH                                                                                                            
-----------------------------------------------                                                                                                           
COLUMN path FORMAT A20                                                                                                                                    
                                                                                                                                                          
WITH t1(id, parent_id, lvl, root_id, path) AS (                                                                                                           
  -- Anchor member.                                                                                                                                       
  SELECT id,                                                                                                                                              
         parent_id,                                                                                                                                       
         1 AS lvl,                                                                                                                                        
         id AS root_id,                                                                                                                                   
         TO_CHAR(id) AS path                                                                                                                              
  FROM   tab1                                                                                                                                             
  WHERE  parent_id IS NULL                                                                                                                                
  UNION ALL                                                                                                                                               
  -- Recursive member.                                                                                                                                    
  SELECT t2.id,                                                                                                                                           
         t2.parent_id,                                                                                                                                    
         lvl+1,                                                                                                                                           
         t1.root_id,                                                                                                                                      
         t1.path || '-' || t2.id AS path                                                                                                                  
  FROM   tab1 t2, t1                                                                                                                                      
  WHERE  t2.parent_id = t1.id                                                                                                                             
)                                                                                                                                                         
SEARCH DEPTH FIRST BY id SET order1                                                                                                                       
SELECT id,                                                                                                                                                
       parent_id,                                                                                                                                         
       RPAD('.', (lvl-1)*2, '.') || id AS tree,                                                                                                           
       lvl,                                                                                                                                               
       root_id,                                                                                                                                           
       path                                                                                                                                               
FROM t1                                                                                                                                                   
ORDER BY order1;                                                                                                                                          
-----------------------------------------------------------------------------------------                                                                 
6- The NOCYCLE and CONNECT_BY_ISCYCLE functionality is replicated using the CYCLE clause.                                                                 
-----------------------------------------------------------------------------------------                                                                 
   Unlike the CONNECT BY NOCYCLE method, which stops at the row before the cycle, this method stops at the row after the cycle.                           
                                                                                                                                                          
WITH t1(id, parent_id, lvl, root_id, path) AS (                                                                                                           
  -- Anchor member.                                                                                                                                       
  SELECT id,                                                                                                                                              
         parent_id,                                                                                                                                       
         1 AS lvl,                                                                                                                                        
         id AS root_id,                                                                                                                                   
         TO_CHAR(id) AS path                                                                                                                              
  FROM   tab1                                                                                                                                             
  WHERE  id = 1                                                                                                                                           
  UNION ALL                                                                                                                                               
  -- Recursive member.                                                                                                                                    
  SELECT t2.id,                                                                                                                                           
         t2.parent_id,                                                                                                                                    
         lvl+1,                                                                                                                                           
         t1.root_id,                                                                                                                                      
         t1.path || '-' || t2.id AS path                                                                                                                  
  FROM   tab1 t2, t1                                                                                                                                      
  WHERE  t2.parent_id = t1.id                                                                                                                             
)                                                                                                                                                         
SEARCH DEPTH FIRST BY id SET order1                                                                                                                       
CYCLE id SET cycle TO 1 DEFAULT 0                                                                                                                         
SELECT id,                                                                                                                                                
       parent_id,                                                                                                                                         
       RPAD('.', (lvl-1)*2, '.') || id AS tree,                                                                                                           
       lvl,                                                                                                                                               
       root_id,                                                                                                                                           
       path,                                                                                                                                              
       cycle                                                                                                                                              
FROM t1                                                                                                                                                   
ORDER BY order1;                                                                                                                                          
******************************************************************
FACTORED SUBQUERY /*+INLINE*/  /*+ MATERIALIZE*/ /*+ CACHE */HINTS 
*******************************************************************
The undocumented MATERIALIZE hint tells the optimizer to resolve the factored subquery as a global temporary table, while INLINE hint tells it to process the query inline AND /*+ CACHE */ caches the factored subquery.
12c "temp_undo_enabled" allows you to use the TEMP rather than the UNDO tablespace for temporary tables, materializations, and factored subqueries.
12c you can use the "create function" syntax within a WITH clause declaration

WITH dept_count AS (
  SELECT /*+ MATERIALIZE */ deptno, COUNT(*) AS dept_count  --global temporary tabe scan
  FROM   emp
  GROUP BY deptno)
SELECT ...

WITH dept_count AS (
  SELECT /*+ INLINE */ deptno, COUNT(*) AS dept_count --inline
  FROM   emp
  GROUP BY deptno)
SELECT ...
WITH
factored_subquery AS -- ANSI SQL-99: "Common Table Expression"
( SELECT 1 AS scalar_value
    FROM DUAL
)
SELECT ( SELECT 1 
           FROM dual 
          WHERE ROWNUM = 1 ) as scalar_subquery
     , scalar_value
  FROM 
( SELECT * 
    FROM factored_subquery ) /* as */ inline_view
/
***********************************************************************************************************                                                                  
II - Analytic functions by Example RANK, DENSE_RANK, FIRST and LAST Analytic Functions                                                                                                                                               
**********************************************************************************************************                                                                   

create table emp ( 
EMPNO    NUMBER(4)    , 
ENAME             VARCHAR2(10) , 
JOB               VARCHAR2(9)  , 
MGR               NUMBER(4)    , 
HIREDATE          DATE         , 
SAL               NUMBER(7,2)  , 
COMM              NUMBER(7,2)  , 
DEPTNO            NUMBER(2)     
) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7369,'SMITH','CLERK',7902,to_date('17/DEC/80','DD/MON/RR'),800,null,20) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7499,'ALLEN','SALESMAN',7698,to_date('20/FEB/81','DD/MON/RR'),1600,300,30) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7521,'WARD','SALESMAN',7698,to_date('22/FEB/81','DD/MON/RR'),1250,500,30) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7566,'JONES','MANAGER',7839,to_date('02/APR/81','DD/MON/RR'),2975,null,20) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7654,'MARTIN','SALESMAN',7698,to_date('28/SEP/81','DD/MON/RR'),1250,1400,30) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7698,'BLAKE','MANAGER',7839,to_date('01/MAY/81','DD/MON/RR'),2850,null,30) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7782,'CLARK','MANAGER',7839,to_date('09/JUN/81','DD/MON/RR'),2450,null,10) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7788,'SCOTT','ANALYST',7566,to_date('09/DEC/82','DD/MON/RR'),3000,null,20) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7839,'KING','PRESIDENT',null,to_date('17/NOV/81','DD/MON/RR'),5000,null,10) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7844,'TURNER','SALESMAN',7698,to_date('08/SEP/81','DD/MON/RR'),1500,null,30) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7876,'ADAMS','CLERK',7788,to_date('12/JAN/83','DD/MON/RR'),1100,null,20) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7900,'JAMES','CLERK',7698,to_date('03/DEC/81','DD/MON/RR'),950,null,30) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7902,'FORD','ANALYST',7566,to_date('03/DEC/81','DD/MON/RR'),3000,null,20) 
/
Insert into emp (EMPNO,ENAME,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO) values (7934,'MILLER','CLERK',7782,to_date('23/JAN/82','DD/MON/RR'),1300,null,10) 
/
1- RANK
SELECT empno,
       deptno,
       sal,
       RANK() OVER (PARTITION BY deptno ORDER BY sal) "rank"
FROM   emp;

    EMPNO     DEPTNO        SAL       rank
---------- ---------- ---------- ----------
      7934         10       1300          1
      7782         10       2450          2
      7654         30       1250          2
      7521         30       1250          2 ---- same salary   
      7844         30       1500          4 ---- rank = + 2 same salary // rank not consecutive
      


    
2- DENSE_RANK
The DENSE_RANK function acts like the RANK function except that it assigns consecutive ranks.
SELECT empno,
       deptno,
       sal,
       DENSE_RANK() OVER (PARTITION BY deptno ORDER BY sal) "rank"
FROM   emp;
    EMPNO     DEPTNO        SAL       rank
---------- ---------- ---------- ----------
      7934         10       1300          1
      7782         10       2450          2
      7654         30       1250          2
      7521         30       1250          2 ---- same salary  
      7844         30       1500          3 ---- Rank =+1  // rank consecutive
  
3- FIRST and LAST :
 return the first or last value from an ordered sequence ( lowest and highest within employee's department)

SELECT empno, deptno,sal,
       MIN(sal) KEEP (DENSE_RANK FIRST ORDER BY sal) OVER (PARTITION BY deptno) "Lowest",   -- or max(sal) keep (dense_rank first order by resolution desc)
       MAX(sal) KEEP (DENSE_RANK LAST ORDER BY sal) OVER (PARTITION BY deptno) "Highest"
FROM   emp
ORDER BY deptno, sal;  

     EMPNO     DEPTNO        SAL     Lowest    Highest
---------- ---------- ---------- ---------- ----------
      7934         10       1300       1300       5000 ---
      7369         20        800        800       3000
      7900         30        950        950       2850
 
 OR 
  
SELECT empno, deptno,sal,
       FIRST_VALUE(sal) OVER (PARTITION BY DEPTNO ORDER BY SAL) "Lowest",
       FIRST_VALUE(sal) OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) "Highest"
       from emp order by deptno,sal;
  
==================================================================================================================
RANK ROW_NUMBER
==================================================================================================================                                                                                                                                                                             
create table tbl(col1 varchar2 (10), col2 varchar2(10),num number,dat date);                                                                                                              
                                                                                                                                                                             
insert into tbl values ('A','X',1,to_date('02-jan','dd-mon'));                                                                                                                                          
insert into tbl values ('A','X',1,to_date('02-jan','dd-mon'));                                                                                                                                          
insert into tbl values ('A','X',1,to_date('02-jan','dd-mon'));                                                                                                                                          
insert into tbl values ('B','Y',1,to_date('03-jan','dd-mon'));                                                                                                                                          
insert into tbl values ('B','Y',1,to_date('03-jan','dd-mon'));                                                                                                                                          
insert into tbl values ('C','Z',1,to_date('01-jan','dd-mon'));                                                                                                                                          
insert into tbl values ('C','Z',1,to_date('01-jan','dd-mon'));                                                                                                                                          
insert into tbl values ('A','A',1,to_date('03-jan','dd-mon'));                                                                                                                                          
insert into tbl values ('M','X',1,to_date('01-Feb','dd-mon'));                                                                                                               
insert into tbl values ('M','R',1,to_date('02-Mar','dd-mon'));                                                                                                               
insert into tbl values ('M','V',1,to_date('03-feb','dd-mon'));                                                                                                        
                                                                                                                                            
                                                                                                                                                                             
select                                                                                                                                                                       
   col1,col2,                                                                                                                                                                    
   row_number() over(partition by col1,col2 order by col1,col2) as nr                                                                                                                
from tbl;                                                                                                                                                                    
                                                                                                                                                                             
select col1,col2,                                                                                                                                                                
sum(num) over (partition by col1,col2 order by col1,col2) as sum                                                                                                                     
from tbl;                                                                                                                                                                    
                                                                                                                                                                             
HI         HO                SUM                                                                                                                                             
---------- ---------- ----------                                                                                                                                             
A          X                   3                                                                                                                                             
A          X                   3                                                                                                                                             
A          X                   3                                                                                                                                             
B          Y                   2                                                                                                                                             
B          Y                   2                                                                                                                                             
C          Z                   2                                                                                                                                             
C          Z                   2                                                                                                                                             
                                                                                                                                                                             
select col1,col2,                                                                                                                                                                
sum(num) over (partition by col1 order by col1,col2) as sum                                                                                                                        
from tbl;                                                                                                                                                                    
HI         HO                SUM                                                                                                                                             
---------- ---------- ----------                                                                                                                                             
A          A                   1                                                                                                                                             
A          X                   4                                                                                                                                             
A          X                   4                                                                                                                                             
A          X                   4                                                                                                                                             
B          Y                   2                                                                                                                                             
B          Y                   2                                                                                                                                             
C          Z                   2                                                                                                                                             
C          Z                   2                                                                                                                                             
                                                                                                                                                                             
                                                                                                                                                                             
                                                                                                                                                                             
select col1,col2,dat,SUM(NUM) OVER (ORDER BY dat ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING)  as col3 from tbl;                                                                             
                                                                                                                                                                             
HI HO DAT    SUM(NUM)OVER(ORDERBYDATROWSBETWEEN1PRECEDINGAND1FOLLOWING)                                                                                                      
-- -- ------ ----------------------------------------------------------                                                                                                      
C  Z  01-jan                                                          2                                                                                                      
C  Z  01-jan                                                          3                                                                                                      
A  X  02-jan                                                          3                                                                                                      
A  X  02-jan                                                          3                                                                                                      
A  X  02-jan                                                          3                                                                                                      
B  Y  03-jan                                                          3                                                                                                      
A  A  03-jan                                                          3                                                                                                      
B  Y  03-jan                                                          2                                                                                                      
                                                                                                                                                                             
select col1,col2,dat,SUM(NUM) OVER (ORDER BY dat ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) from tbl; (example curent =1 + preced 1 +folowing 1= 3                        
                                                                                                                                                                             
HI HO DAT    SUM(NUM)OVER(ORDERBYDATROWSBETWEENUNBOUNDEDPRECEDINGANDCURRENTROW)                                                                                              
-- -- ------ ------------------------------------------------------------------                                                                                              
C  Z  01-jan                                                                  1                                                                                              
C  Z  01-jan                                                                  2                                                                                              
A  X  02-jan                                                                  3                                                                                              
A  X  02-jan                                                                  4                                                                                              
A  X  02-jan                                                                  5                                                                                              
B  Y  03-jan                                                                  6                                                                                              
A  A  03-jan                                                                  7                                                                                              
B  Y  03-jan                                                                  8                                                                                              
                                                                                                                                                                             
                                                                                                                                                                             
select HI,HO,dat,COUNT(*) OVER ( ) SM   from tbl  where dat between '01-jan' and '02-jan'     (Sum of count where condition is met)                                          
order by 3 ;                                                                                                                                                                 
                                                                                                                                                                             
col1  col2   DAT            SM                                                                                                                                                      
---- ---- -------- ----------                                                                                                                                                      
C     Z    01-jan          5                                                                                                                                                      
C     Z    01-jan          5                                                                                                                                                      
A     X    02-jan          5                                                                                                                                                      
A     X    02-jan          5                                                                                                                                                      
A     X    02-jan          5                                                                                                                                                      
                                                                                                                                                                             
                                                                                                                                                                             
- for each , the total salary of employees hired in the past one year from his or her hire date                                                                              
                                                                                                                                                                             
select col1,col2,dat,COUNT(*) OVER (ORDER BY dat RANGE NUMTOYMINTERVAL(1,'YEAR') PRECEDING) AS t_sal                                                                             
from tbl ;                                                                                                                                                                   
                                                                                                                                                                             
                                                                                                                                                                             
                                                                                                                                                                             
                                                                                                                                                                             
BREAK ON COMPUTE OPTIONS :                                                                                                                                                   
--------------------------                                                                                                                                                   
BREAK ON  deptno  ON  REPORT                                                                                                                                                 
COMPUTE SUM LABEL subtotal    OF sal ON deptno                                                                                                                               
COMPUTE SUM LABEL grandtotal  OF sal ON REPORT                                                                                                                               
                                                                                                                                                                             
SELECT    ename, sal, deptno                                                                                                                                                 
FROM        scott.emp                                                                                                                                                        
ORDER BY  deptno;                                                                                                                                                            
Output:                                                                                                                                                                      
ENAME             SAL     DEPTNO                                                                                                                                             
---------- ---------- ----------                                                                                                                                             
CLARK            2450         10                                                                                                                                             
KING             5000                                                                                                                                                        
MILLER           1300                                                                                                                                                        
           ---------- **********                                                                                                                                             
                 8750 subtotal                                                                                                                                               
JONES            2975         20                                                                                                                                             
FORD             3000                                                                                                                                                        
ADAMS            1100                                                                                                                                                        
SMITH             800                                                                                                                                                        
SCOTT            3000                                                                                                                                                        
           ---------- **********                                                                                                                                             
                10875 subtotal                                                                                                                                               
WARD             1250         30                                                                                                                                             
TURNER           1500                                                                                                                                                        
ALLEN            1600                                                                                                                                                        
JAMES             950                                                                                                                                                        
BLAKE            2850                                                                                                                                                        
MARTIN           1250                                                                                                                                                        
           ---------- **********                                                                                                                                             
                 9400 subtotal                                                                                                                                               
           ----------                                                                                                                                                        
grandtotal      29025                                                                                                                                                        
--------TOTALS                                                                                                                                                               
SELECT   DECODE (GROUPING (ename), 0, ename, 'Total') ename, SUM (sal),                                                                                                      
         deptno                                                                                                                                                              
    FROM emp_test                                                                                                                                                            
GROUP BY  deptno,ROLLUP ((ename, sal))                                                                                                                                       
ORDER BY deptno;                                                                                                                                                             
                                                                                                                                                                             
                                                                                                                                                                             
ENAME        SUM(SAL)     DEPTNO                                                                                                                                             
---------- ---------- ----------                                                                                                                                             
CLARK            2450         10                                                                                                                                             
KING             5000         10                                                                                                                                             
MILLER           1300         10                                                                                                                                             
Total            8750         10++                                                                                                                                           
ADAMS            1100         20                                                                                                                                             
FORD             3000         20                                                                                                                                             
JONES            2975         20                                                                                                                                             
SCOTT            3000         20                                                                                                                                             
SMITH             800         20                                                                                                                                             
Total           10875         20++                                                                                                                                           
ALLEN            1600         30                                                                                                                                             
BLAKE            2850         30                                                                                                                                             
JAMES             950         30                                                                                                                                             
MARTIN           1250         30                                                                                                                                             
TURNER           1500         30                                                                                                                                             
WARD             1250         30                                                                                                                                             
Total            9400         30++                                                                                                                                           
                                                                                                                                                                             
SQL> select nvl(to_char(deptno),'GRAND TOTAL') deptno,                                                                                                                       
           nvl(ename,decode(deptno,null,null,'DEPT '||deptno||' TOTAL')) ename,                                                                                              
          sum(sal) sal                                                                                                                                                       
      from emp                                                                                                                                                               
     group by rollup (deptno, ename);                                                                                                                                        
                                                                                                                                                                             
DEPTNO      ENAME                  SAL                                                                                                                                       
----------- --------------- ----------                                                                                                                                       
10          KING                  5000                                                                                                                                       
10          CLARK                 2450                                                                                                                                       
10          MILLER                1300                                                                                                                                       
10          DEPT 10 TOTAL         8750                                                                                                                                       
20          FORD                  3000                                                                                                                                       
20          ADAMS                 1100                                                                                                                                       
20          JONES                 2975                                                                                                                                       
20          SCOTT                 3000                                                                                                                                       
20          SMITH                  800                                                                                                                                       
20          DEPT 20 TOTAL        10875                                                                                                                                       
30          WARD                  1250                                                                                                                                       
30          ALLEN                 1600                                                                                                                                       
30          BLAKE                 2850                                                                                                                                       
30          JAMES                  950                                                                                                                                       
30          MARTIN                1250                                                                                                                                       
30          TURNER                1500                                                                                                                                       
30          DEPT 30 TOTAL         9400                                                                                                                                       
GRAND TOTAL                      29025                                                                                                                                       
                                                                                                                                                                             
==============================
CORRELATED vs NESTED SUBQUERY   
==============================
>> Nested and correlated subqueries show up in the WHERE clause of a SQL statement.
- NESTED subquery     : subquery does not reference columns from the outer query.
- CORRELATED subquery : subquery depends references columns from the outer query in order to complete // evaluated once FOR EACH ROW as opposed to a normal subquery which is evaluated only once for each table. 
- SCALAR subquery     :  returns one row and one column. Whenever the , we speak of a 
12c A correlated subquery conceptually is evaluated once for each row processed by the parent statement, however the optimizer is free to rewrite the query as a join or using some other technique to arrive at a query that is semantically equivalent. 

kh85124@MCRORAT02> select (select count(*) from (select * from emp e where ename =emp.ename )) from emp;
select (select count(*) from (select * from emp e where ename =emp.ename )) from emp                    
                                                               *                                        
ERROR at line 1:                                                                                        
ORA-00904: "EMP"."ENAME": invalid identifier                                                            
12c 

                                                                                                                           SELECT  x.*, count(*)                                                                                                                          
                                                                                                                              FROM (                                                                                                                                      
SELECT   a.file_id,                                                                                                           SELECT   a.file_id,                                                                                                                         
         a.sale_start,                                                                                                                 a.sale_start,                                                                                                                      
         a.activity_start,                                                                                                             a.activity_start,                                                                                                                  
         a.activity_end,                                                                                                               a.activity_end,                                                                                                                    
         a.item_code_cust,                                                                                                             a.item_code_cust,                                                                                                                  
         a.division,                                                                                                                   a.division,                                                                                                                        
         (SELECT MAX (DISTINCT (NVL (b.advertised, 'No')))                                                                            MAX( nvl(advertised,'No') ) OVER                                                                                           
            FROM arch b                                                                                                                  (PARTITION BY sale_start,activity_start,activity_end,item_code_cust,division) advertised,                          
           WHERE b.file_id = a.file_id                                                                                                FIRST_VALUE(activity_id) OVER                                                                                                      
             AND NVL (b.sale_start, 'NULL') = NVL (a.sale_start, 'NULL')                                                                 ( PARTITION BY sale_start, activity_start, activity_end, item_code_cust, division, upper(advertised)                   
             AND NVL (b.activity_start, 'NULL') = NVL (a.activity_start, 'NULL')                                                               ORDER BY activity_retail/TO_NUMBER(activity_mult)) primary_id                                                    
             AND NVL (b.activity_end, 'NULL') = NVL (a.activity_end, 'NULL')                                                      FROM arch a                                                                                                                             
             AND b.item_code_cust = a.item_code_cust                                                                             WHERE a.file_id = 217                                                                                                                    
             AND b.division = a.division) advertised,                                                                            ) x                                                                                                                                      
         (SELECT activity_id                                                                                                  GROUP BY x.file_id, x.sale_start, x.activity_start, x.activity_end, x.item_code_cust, x.division, x.advertised, x.advertised, x.primary_id  
            FROM (SELECT c.activity_id,                                                                       ===>              HAVING COUNT (*) > 1;                                                                                                                     
                         ROW_NUMBER () OVER (ORDER BY (c.activity_retail / c.activity_mult)) rnk                       
                    FROM arch c                                                                                      
                       WHERE NVL (c.sale_start, 'NULL') = NVL (a.sale_start, 'NULL')
                       AND NVL (c.activity_start, 'NULL') = NVL (a.activity_start, 'NULL')
                       AND NVL (c.activity_end, 'NULL') = NVL (a.activity_end, 'NULL')
                       AND c.item_code_cust = a.item_code_cust
                       AND c.division = a.division
                       AND UPPER (NVL (c.advertised, 'N')) = a.advertised
                       AND c.file_id = 217)
           WHERE rnk = 1) primary_id,
         COUNT (*)
    FROM arch a
   WHERE a.file_id = 217
GROUP BY a.file_id, a.sale_start, a.activity_start, a.activity_end, a.item_code_cust, a.division
  HAVING COUNT (*) > 1;

**** ORA-00904: "A"."ADVERTISED": invalid identifier
                                                                                                           
                                                                                                                                                                                                                         
====
SELECT empno, deptno,sal,
       MIN(sal) KEEP (DENSE_RANK FIRST ORDER BY sal) OVER (PARTITION BY deptno) "Lowest",   -- or max(sal) keep (dense_rank first order by resolution desc)
       MAX(sal) KEEP (DENSE_RANK LAST ORDER BY sal) OVER (PARTITION BY deptno) "Highest"
FROM   emp
ORDER BY deptno, sal;  
 
OR 
  
SELECT empno, deptno,sal,
       FIRST_VALUE(sal) OVER (PARTITION BY DEPTNO ORDER BY SAL) "Lowest",
       FIRST_VALUE(sal) OVER (PARTITION BY DEPTNO ORDER BY SAL DESC) "Highest"
       from emp order by deptno,sal;

SELECT p.post_id,                                                                                                          SELECT  p.post_id, c.*                                                                        
(select * from                                                                                                             FROM    posts                                                                                                                                 
(select comment_body from comments where post_id = p.post_id       =====>                                                  JOIN    (                                                                                                                                     
 order by created_date asc) where rownum=1                                                                                         SELECT  c.*, ROW_NUMBER() OVER (PARTITION BY post_id ORDER BY created_date ASC) AS rn                                                 
) the_first_comment                                                                                                                FROM    comments c) c                                                                                                                 
FROM posts p                                                                                                               ON      c.post_id = p.post_id                                                                                                                 
                                                                                                                           AND rn = 1                        
********************************************************************************


UPDATE vs merge 

ops$tkyte%ORA10GR2> merge into a_performance_info                                                        
     using (select horse_code, race_date                                                                  
              from (select horse_code, race_date,                                                         
                                   DENSE_RANK() OVER (PARTITION BY horse_code ORDER BY race_date DESC) dr 
                                      from a_performance                                                  
                                     where race_date < to_date( '21-oct-2009' )                           
                               )                                                                         
                     where dr = 5) x                                                                     
     on (a_performance_info.horse_code = x.horse_code)                                                   
     when matched then update set fifthrecent_date = race_date                                           
     /                                                                                                   
                                                                                                         
2 rows merged.                                                                                           
                                                                                                         
ops$tkyte%ORA10GR2> merge into a_performance_info                                                        
     using (select horse_code, max(race_date) race_date                                                  
              from (select horse_code, race_date,                                                        
                                   DENSE_RANK() OVER (PARTITION BY horse_code ORDER BY race_date DESC) dr
                                      from a_performance                                                 
                                     where race_date < to_date( '21-oct-2009' )                          
                               )                                                                         
                     where dr = 5                                                                        
                 group by horse_code) x                                                                  
     on (a_performance_info.horse_code = x.horse_code)                                                   
     when matched then update set fifthrecent_date = race_date                                           
     /                                                                                                   
    
==============================================
inline view scalar subquery factored subquery 
==============================================

WITH
factored_subquery AS -- ANSI SQL-99: "Common Table Expression"
( SELECT 1 AS scalar_value
    FROM DUAL
)
SELECT ( SELECT 1 
           FROM dual 
          WHERE ROWNUM = 1 ) as scalar_subquery
     , scalar_value
  FROM 
( SELECT * 
    FROM factored_subquery ) /* as */ inline_view
/

========================================================
a) scalar subqueries - a single row, single column query that you use in place of a "column", it looks like a column or function. 

b) an inline view - the from (select ... from (select .... ) ) 


The scalar subqueries - the optimizer does not roll/merge the scalar subquery into the outer query. should be the exception - not the rule. replace by JOINING instead of using scalar subqueries.  
scalar subqueries are good for small sets, whether that be a small set because you only fetch 25 rows out of a million, or it is small because - well - it is small. 
if you have a query 

select (select t2.a from t2 where t2.c = t1.c),                           select t2.a, col_2, col_3, t2.b, t3.x 
       col_2,col_3,                                JOIN T2 and T3 =>      from ...., T2, T3                   
       (select t2.b from t2 where t2.c = t1.c),                           where ....                           
       (select t3.x from t3 where t3.d = t1.d),                           and t2.c(+) = t1.c                 
        from .....                                                        and t3.d(+) = t1.d  -- outer join IF and ONLY IF necessary


Even if the query was something like: 

select (select count(*) from t2 where t2.c = t1.c),                       select t2.a, col_2, col_3, t2.b, t3.x                                
       col_2,                                                               from ...., (select count(*) a, max(b) b, c from t2 group by c) T2, 
       col_3,                                                                          (select sum(x), d from t3 group by d) T3                
       (select max(b) from t2 where t2.c = t1.c),  you would just =>        where ....                                                          
       (select sum(x) from t3 where t3.d = t1.d),                            and t2.c(+) = t1.c                                                
  from .....                                                                 and t3.d(+) = t1.d  -- outer join IF and ONLY IF necessary        


 if you are going to call PLSQL from SQL, I recommend always using a scalar subquery, that is, instead of: 
                                                                                                          
select f(x)                                select (select f(x) from dual)                                                                         
from t                code:                from t                                                                                                     
where g(y) = ?;                            where (select g(y) from dual) = ?;                                                                  
                                                                                                           
                                                                                                           
CREATE TABLE AUDITHISTORY(                                                                                                               
CASENUM numeric(20, 0) NOT NULL,                                                                                                              
AUDIT_DATE date NOT NULL,                                                                                 
USER_NAME varchar(255) NULL,                                                                              
AUDIT_USECS numeric(6, 0) NOT NULL,                                                                       
TYPE_ID INT NOT NULL    )         

insert into AUDITHISTORY(CASENUM, AUDIT_DATE,USER_NAME,AUDIT_USECS,TYPE_ID) values(10 ,to_date('12-MAR-10','DD-MM-RR'),'USER',100,1);
insert into AUDITHISTORY(CASENUM, AUDIT_DATE,USER_NAME,AUDIT_USECS,TYPE_ID) values(10 ,to_date('14-MAR-10','DD-MM-RR'),'USER',100,2);
insert into AUDITHISTORY(CASENUM, AUDIT_DATE,USER_NAME,AUDIT_USECS,TYPE_ID) values(10 ,to_date('16-MAR-10','DD-MM-RR'),'USER',100,2);    
    
 Q:
SELECT T.CASENUM,                                                                                     
 T.USER_NAME,                                                                                                                         
 T.AUDIT_DATE AS STARTED,                                                                        
 ( SELECT max(S.AUDIT_DATE) keep (dense_rank first order by S.AUDIT_DATE ASC,S.AUDIT_USECS ASC)
     from AUDITHISTORY S                                                                         
     WHERE S.CASENUM=T.CASENUM AND TYPE_ID=2                                                     
     AND S.USER_NAME=T.USER_NAME                                                                 
     AND (S.AUDIT_DATE > T.AUDIT_DATE OR (S.AUDIT_DATE = T.AUDIT_DATE AND S.AUDIT_USECS > T.AUDIT_USECS))                                                                                           
   ) as ended                                                                                      
 FROM AUDITHISTORY T WHERE TYPE_ID=1;
 
 Q2:
                                                            
 
 
 first_value(AUDIT_DATE) over (partition by USER_NAME,CASENUM order by AUDIT_DATE ASC,AUDIT_USECS ASC)                                                                                                                
   MAX(advertised) OVER  (PARTITION BY sale_start,activity_start,activity_end,item_code_cust,division) advertised,                                
      FIRST_VALUE(activity_id) OVER    ( PARTITION BY sale_start, activity_start, activity_end, item_code_cust, division, upper(advertised)                     
       ORDER BY activity_retail/TO_NUMBER(activity_mult)) primary_id                                                        
                                                                                                                              
 
 
 
 PIVOT Clause    :11g                                                                   insert into orders(order_id,customer_ref,product_id)  values (50001,'SMITH',10)           
                                                                                        insert into orders(order_id,customer_ref,product_id) values (50002,'SMITH',20)            
 CREATE TABLE orders                                                                    insert into orders(order_id,customer_ref,product_id) values (50003,'ANDERSON',30);         
( order_id integer NOT NULL,                                                            insert into orders(order_id,customer_ref,product_id) values (50004,'ANDERSON',40);         
  customer_ref varchar2(50) NOT NULL,                                                   insert into orders(order_id,customer_ref,product_id) values (50005,'JONES',10);           
  order_date date,                                                                      insert into orders(order_id,customer_ref,product_id) values (50006,'JONES',20);           
  product_id integer,                                                                   insert into orders(order_id,customer_ref,product_id) values (50007,'SMITH',20);           
  quantity integer,                                                                     insert into orders(order_id,customer_ref,product_id) values (50008,'SMITH',10);           
  CONSTRAINT orders_pk PRIMARY KEY (order_id)                                           insert into orders(order_id,customer_ref,product_id) values (50009,'SMITH',20);              
);

                                                                                        
  SELECT * FROM                                                        
  (SELECT customer_ref, product_id FROM orders)                                              10g :                                                          
  PIVOT                                                                                     select  customer_ref,                                      
  ( COUNT(product_id)                                                                         count(case when product_id=10 then product_id else null end) as "10",
   FOR product_id IN (10, 20, 30,40))                                                            count(case when product_id=20  then product_id else null end) as "20",
  ORDER BY customer_ref;                                                                      count(case when product_id=30  then product_id else null end) as "30" 
                                                                                            from orders                                       
                                                                                            group by customer_ref ;      
CUSTOMER_REF                                               10         20         30                              
-------------------------------------------------- ---------- ---------- ----------
JONES                                                       0          1          0
SMITH                                                       1          2          0
ANDERSON                                                    0          0          1