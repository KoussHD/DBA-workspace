SPOOL PROBLEM  : 
Usage: SET SQLPLUSCOMPAT[IBILITY] version.release.[update]
SET SQLPLUSCOMPATIBILITY  10.2.0 or 11.2.0



SET SQLCONTINUE 
Sets the character sequence SQL*Plus displays as a prompt after you continue a SQL*Plus command on an additional line using a hyphen (-).
Example
To set the SQL*Plus command continuation prompt to an exclamation point followed by a space, enter

SET SQLCONTINUE '! '
SQL*Plus will prompt for continuation as follows:
TTITLE 'MONTHLY INCOME' -
! RIGHT SQL.PNO SKIP 2 -
! CENTER 'PC DIVISION'
The default continuation prompt is "> ".
***********************************************************************************************************
Analytic functions by Example 
**********************************************************************************************************

create table tbl(hi varchar2 (10), ho varchar2(10),num number);

insert into tbl values ('A','X',1);
insert into tbl values ('A','X',1);
insert into tbl values ('A','X',1);
insert into tbl values ('B','Y',1);
insert into tbl values ('B','Y',1);
insert into tbl values ('C','Z',1);
insert into tbl values ('C','Z',1);
insert into tbl values ('A','A',1);
insert into tbl values ('M','X',1,to_date('01-Feb','dd-mon'));
insert into tbl values ('M','R',1,to_date('02-Mar','dd-mon'));
insert into tbl values ('M',''V',1,to_date('03-fev-13','dd-mon-yy'));                      
update tbl set DAT=to_date(-jan                        
                       
select                 
   hi,ho,              
   row_number() over(partition by hi,ho order by hi,ho) as nr
from tbl;              
                      
select hi,ho,
sum(num) over (partition by hi,ho order by hi,ho) as sum
from tbl;

HI         HO                SUM
---------- ---------- ----------
A          X                   3
A          X                   3
A          X                   3
B          Y                   2
B          Y                   2
C          Z                   2
C          Z                   2

select hi,ho,                                               
sum(num) over (partition by hi order by hi,ho) as sum    
from tbl;  
HI         HO                SUM
---------- ---------- ----------
A          A                   1
A          X                   4
A          X                   4
A          X                   4
B          Y                   2
B          Y                   2
C          Z                   2
C          Z                   2

   

select HI,HO,dat,SUM(NUM) OVER (ORDER BY dat ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) from tbl;  

HI HO DAT    SUM(NUM)OVER(ORDERBYDATROWSBETWEEN1PRECEDINGAND1FOLLOWING)
-- -- ------ ----------------------------------------------------------
C  Z  01-jan                                                          2
C  Z  01-jan                                                          3
A  X  02-jan                                                          3
A  X  02-jan                                                          3
A  X  02-jan                                                          3
B  Y  03-jan                                                          3
A  A  03-jan                                                          3
B  Y  03-jan                                                          2

select HI,HO,dat,SUM(NUM) OVER (ORDER BY dat ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) from tbl; (example curent =1 + preced 1 +folowing 1= 3

HI HO DAT    SUM(NUM)OVER(ORDERBYDATROWSBETWEENUNBOUNDEDPRECEDINGANDCURRENTROW)
-- -- ------ ------------------------------------------------------------------
C  Z  01-jan                                                                  1
C  Z  01-jan                                                                  2
A  X  02-jan                                                                  3
A  X  02-jan                                                                  4
A  X  02-jan                                                                  5
B  Y  03-jan                                                                  6
A  A  03-jan                                                                  7
B  Y  03-jan                                                                  8   


select HI,HO,dat,COUNT(*) OVER ( ) SM   from tbl  where dat between '01-jan' and '02-jan'     (Sum of count where condition is met)
order by 3 ;           

HI HO DAT            SM
-- -- ------ ----------
C  Z  01-jan          5
C  Z  01-jan          5
A  X  02-jan          5
A  X  02-jan          5
A  X  02-jan          5


- for each , the total salary of employees hired in the past one year from his or her hire date

select HI,HO,dat,COUNT(*) OVER (ORDER BY dat RANGE NUMTOYMINTERVAL(1,'YEAR') PRECEDING) AS t_sal
from tbl ;




BREAK ON COMPUTE OPTIONS :
--------------------------
BREAK ON  deptno  ON  REPORT
COMPUTE SUM LABEL subtotal    OF sal ON deptno
COMPUTE SUM LABEL grandtotal  OF sal ON REPORT

SELECT    ename, sal, deptno 
FROM        scott.emp 
ORDER BY  deptno;
Output:
ENAME             SAL     DEPTNO
---------- ---------- ----------
CLARK            2450         10
KING             5000
MILLER           1300
           ---------- **********
                 8750 subtotal
JONES            2975         20
FORD             3000
ADAMS            1100
SMITH             800
SCOTT            3000
           ---------- **********
                10875 subtotal
WARD             1250         30
TURNER           1500
ALLEN            1600
JAMES             950
BLAKE            2850
MARTIN           1250
           ---------- **********
                 9400 subtotal
           ----------
grandtotal      29025
--------TOTALS
SELECT   DECODE (GROUPING (ename), 0, ename, 'Total') ename, SUM (sal),
         deptno
    FROM emp_test
GROUP BY  deptno,ROLLUP ((ename, sal))
ORDER BY deptno;


ENAME        SUM(SAL)     DEPTNO
---------- ---------- ----------
CLARK            2450         10
KING             5000         10
MILLER           1300         10
Total            8750         10++
ADAMS            1100         20
FORD             3000         20
JONES            2975         20
SCOTT            3000         20
SMITH             800         20
Total           10875         20++
ALLEN            1600         30
BLAKE            2850         30
JAMES             950         30
MARTIN           1250         30
TURNER           1500         30
WARD             1250         30
Total            9400         30++

SQL> select nvl(to_char(deptno),'GRAND TOTAL') deptno,
           nvl(ename,decode(deptno,null,null,'DEPT '||deptno||' TOTAL')) ename,
          sum(sal) sal
      from emp
     group by rollup (deptno, ename);

DEPTNO      ENAME                  SAL
----------- --------------- ----------
10          KING                  5000
10          CLARK                 2450
10          MILLER                1300
10          DEPT 10 TOTAL         8750
20          FORD                  3000
20          ADAMS                 1100
20          JONES                 2975
20          SCOTT                 3000
20          SMITH                  800
20          DEPT 20 TOTAL        10875
30          WARD                  1250
30          ALLEN                 1600
30          BLAKE                 2850
30          JAMES                  950
30          MARTIN                1250
30          TURNER                1500
30          DEPT 30 TOTAL         9400
GRAND TOTAL                      29025


===================
CORRELATED SUBQUERY   
===================
SQL query that depends on values executed by an outer query in order to complete and // evaluated once FOR EACH ROW as opposed to a normal subquery which is evaluated only once for each table. 

kh85124@MCRORAT02> select (select count(*) from (select * from emp e where ename =emp.ename )) from emp;
select (select count(*) from (select * from emp e where ename =emp.ename )) from emp                    
                                                               *                                        
ERROR at line 1:                                                                                        
ORA-00904: "EMP"."ENAME": invalid identifier                                                            


                                                                                                                           SELECT  x.*, count(*)                                                                                                                          
                                                                                                                              FROM (                                                                                                                                      
SELECT   a.file_id,                                                                                                           SELECT   a.file_id,                                                                                                                         
         a.sale_start,                                                                                                                 a.sale_start,                                                                                                                      
         a.activity_start,                                                                                                             a.activity_start,                                                                                                                  
         a.activity_end,                                                                                                               a.activity_end,                                                                                                                    
         a.item_code_cust,                                                                                                             a.item_code_cust,                                                                                                                  
         a.division,                                                                                                                   a.division,                                                                                                                        
         (SELECT MAX (DISTINCT (NVL (b.advertised, 'No')))                                                                            MAX( nvl(advertised,'No') ) OVER                                                                                           
            FROM arch b                                                                                                                  (PARTITION BY sale_start,activity_start,activity_end,item_code_cust,division) advertised,                          
           WHERE b.file_id = a.file_id                                                                                                FIRST_VALUE(activity_id) OVER                                                                                                      
             AND NVL (b.sale_start, 'NULL') = NVL (a.sale_start, 'NULL')                                                                 ( PARTITION BY sale_start, activity_start, activity_end, item_code_cust, division, upper(advertised)                   
             AND NVL (b.activity_start, 'NULL') = NVL (a.activity_start, 'NULL')                                                               ORDER BY activity_retail/TO_NUMBER(activity_mult)) primary_id                                                    
             AND NVL (b.activity_end, 'NULL') = NVL (a.activity_end, 'NULL')                                                      FROM arch a                                                                                                                             
             AND b.item_code_cust = a.item_code_cust                                                                             WHERE a.file_id = 217                                                                                                                    
             AND b.division = a.division) advertised,                                                                            ) x                                                                                                                                      
         (SELECT activity_id                                                                                                  GROUP BY x.file_id, x.sale_start, x.activity_start, x.activity_end, x.item_code_cust, x.division, x.advertised, x.advertised, x.primary_id  
            FROM (SELECT c.activity_id,                                                                       ===>              HAVING COUNT (*) > 1;                                                                                                                     
                         ROW_NUMBER () OVER (ORDER BY (c.activity_retail / c.activity_mult)) rnk                       
                    FROM arch c                                                                                      
                       WHERE NVL (c.sale_start, 'NULL') = NVL (a.sale_start, 'NULL')
                       AND NVL (c.activity_start, 'NULL') = NVL (a.activity_start, 'NULL')
                       AND NVL (c.activity_end, 'NULL') = NVL (a.activity_end, 'NULL')
                       AND c.item_code_cust = a.item_code_cust
                       AND c.division = a.division
                       AND UPPER (NVL (c.advertised, 'N')) = a.advertised
                       AND c.file_id = 217)
           WHERE rnk = 1) primary_id,
         COUNT (*)
    FROM arch a
   WHERE a.file_id = 217
GROUP BY a.file_id, a.sale_start, a.activity_start, a.activity_end, a.item_code_cust, a.division
  HAVING COUNT (*) > 1;

**** ORA-00904: "A"."ADVERTISED": invalid identifier


UPDATE vs merge 

ops$tkyte%ORA10GR2> merge into a_performance_info                                                        
     using (select horse_code, race_date                                                                  
              from (select horse_code, race_date,                                                         
                                   DENSE_RANK() OVER (PARTITION BY horse_code ORDER BY race_date DESC) dr 
                                      from a_performance                                                  
                                     where race_date < to_date( '21-oct-2009' )                           
                               )                                                                         
                     where dr = 5) x                                                                     
     on (a_performance_info.horse_code = x.horse_code)                                                   
     when matched then update set fifthrecent_date = race_date                                           
     /                                                                                                   
                                                                                                         
2 rows merged.                                                                                           
                                                                                                         
ops$tkyte%ORA10GR2> merge into a_performance_info                                                        
     using (select horse_code, max(race_date) race_date                                                  
              from (select horse_code, race_date,                                                        
                                   DENSE_RANK() OVER (PARTITION BY horse_code ORDER BY race_date DESC) dr
                                      from a_performance                                                 
                                     where race_date < to_date( '21-oct-2009' )                          
                               )                                                                         
                     where dr = 5                                                                        
                 group by horse_code) x                                                                  
     on (a_performance_info.horse_code = x.horse_code)                                                   
     when matched then update set fifthrecent_date = race_date                                           
     /                                                                                                   
    
==============================================
inline view scalar subquery factored subquery 
==============================================

WITH
factored_subquery AS -- ANSI SQL-99: "Common Table Expression"
( SELECT 1 AS scalar_value
    FROM DUAL
)
SELECT ( SELECT 1 
           FROM dual 
          WHERE ROWNUM = 1 ) as scalar_subquery
     , scalar_value
  FROM 
( SELECT * 
    FROM factored_subquery ) /* as */ inline_view
/

========================================================
a) scalar subqueries - a single row, single column query that you use in place of a "column", it looks like a column or function. 

b) an inline view - the from (select ... from (select .... ) ) 


The scalar subqueries - the optimizer does not roll/merge the scalar subquery into the outer query. should be the exception - not the rule. replace by JOINING instead of using scalar subqueries.  
scalar subqueries are good for small sets, whether that be a small set because you only fetch 25 rows out of a million, or it is small because - well - it is small. 
if you have a query 

select (select t2.a from t2 where t2.c = t1.c),                           select t2.a, col_2, col_3, t2.b, t3.x 
       col_2,col_3,                                JOIN T2 and T3 =>      from ...., T2, T3                   
       (select t2.b from t2 where t2.c = t1.c),                           where ....                           
       (select t3.x from t3 where t3.d = t1.d),                           and t2.c(+) = t1.c                 
        from .....                                                        and t3.d(+) = t1.d  -- outer join IF and ONLY IF necessary


Even if the query was something like: 

select (select count(*) from t2 where t2.c = t1.c),                       select t2.a, col_2, col_3, t2.b, t3.x                                
       col_2,                                                               from ...., (select count(*) a, max(b) b, c from t2 group by c) T2, 
       col_3,                                                                          (select sum(x), d from t3 group by d) T3                
       (select max(b) from t2 where t2.c = t1.c),  you would just =>        where ....                                                          
       (select sum(x) from t3 where t3.d = t1.d),                            and t2.c(+) = t1.c                                                
  from .....                                                                 and t3.d(+) = t1.d  -- outer join IF and ONLY IF necessary        


 if you are going to call PLSQL from SQL, I recommend always using a scalar subquery, that is, instead of: 
                                                                                                          
select f(x)                                select (select f(x) from dual)                                                                         
from t                code:                from t                                                                                                     
where g(y) = ?;                            where (select g(y) from dual) = ?;                                                                  
                                                                                                           
                                                                                                           
                                                                                                      
                                                                                                           
                                                                       
                                                                       
                                                                       



-SPOOL : If you wish to append alphanumeric characters immediately after a substitution variable, use the value of SET CONCAT to separate the variable name from the following text. 
The default value of SET CONCAT is a single period (.)
 spool &mycity.Australia.txt
  column dcol new_value mydate noprint
  select to_char(sysdate,'YYYYMMDD') dcol from dual;
    spool &mydate.report.txt
 
 

ORA-20000: ORU-10027: buffer overflow
fix:


PL/SQL: DBMS_OUTPUT.ENABLE (buffer_size => NULL);
SQL*Plus: set serveroutput on size unlimited


NLS_CHARACTER=
select * from nls_database_parameters where parameter='NLS_NCHAR_CHARACTERSET';

Direct connection
scott/tiger@(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=tkyte-pc.us.oracle.com)(POR
T=1521))(CONNECT_DATA=(SERVICE_NAME=ora10g)))


 SHUTDOWN IMMEDIATE;                                          
 STARTUP MOUNT;                                               
ALTER SYSTEM ENABLE RESTRICTED SESSION;                      
ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0;                      
alter session set current_schema=SCHEMA_NAME
ALTER SYSTEM SET AQ_TM_PROCESSES=0;                          
SELECT SYSING.F_GEN_PWD FROM DUAL
ALTER DATABASE OPEN;                                         
ALTER DATABASE NATIONAL CHARACTER SET INTERNAL_USE AL16UTF16;
SELECT sequence_name, (last_number + increment_by) NEXT_VALUE FROM dba_sequences where qequence_name ='CAL3_AGR';
SHUTDOWN IMMEDIATE;                                          


declare 

next_val NUMBER;
new_next_val NUMBER;
incr NUMBER;
max_key NUMBER;

v_code NUMBER;
v_errmsg VARCHAR2(64);

BEGIN

SAVEPOINT start_transaction;

    -- get the max PK from the table that's using the sequence
    select max(library_document_key) into max_key from library_documents;
    
    -- then read nextval from the sequence
    EXECUTE IMMEDIATE 'select ld2_seq.nextval from dual' into next_val;
    DBMS_OUTPUT.PUT_LINE('ld2_seq next_val ' || next_val);

    -- calculate the desired next increment for the sequence
    incr := max_key - next_val + 1;
    EXECUTE IMMEDIATE 'ALTER SEQUENCE ld2_seq increment by ' || incr;
    EXECUTE IMMEDIATE 'select ld2_seq.nextval from dual' into new_next_val;
    EXECUTE IMMEDIATE 'ALTER SEQUENCE ld2_seq increment by 1';
    DBMS_OUTPUT.PUT_LINE('ld2_seq new_next_val ' || new_next_val);

commit;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK to start_transaction;
    DBMS_OUTPUT.PUT_LINE('Error code ' || v_code || ': ' || v_errmsg);    
end;   


--update lams.paragraph  a set  
--PARAGRAPHTEXT_EN      = (select PARAGRAPHTEXT_EN from lams.paragraph@LAMS_GAMMA.ING.BE m where a.PARAGRAPHID=m.PARAGRAPHID ),
--PARAGRAPHTEXT_FR       = (select PARAGRAPHTEXT_FR from lams.paragraph@LAMS_GAMMA.ING.BE m where a.PARAGRAPHID=m.PARAGRAPHID),
--PARAGRAPHTEXT_NL       = (select PARAGRAPHTEXT_NL from lams.paragraph@LAMS_GAMMA.ING.BE m where a.PARAGRAPHID=m.PARAGRAPHID),
--PARAGRAPHTEXT_DE       = (select PARAGRAPHTEXT_DE from lams.paragraph@LAMS_GAMMA.ING.BE m where a.PARAGRAPHID=m.PARAGRAPHID),
--PARAGRAPHEMAILTEXT_EN  = (select PARAGRAPHEMAILTEXT_EN from lams.paragraph@LAMS_GAMMA.ING.BE m where a.PARAGRAPHID=m.PARAGRAPHID),
--PARAGRAPHEMAILTEXT_FR  = (select PARAGRAPHEMAILTEXT_FR from lams.paragraph@LAMS_GAMMA.ING.BE m where a.PARAGRAPHID=m.PARAGRAPHID),
--PARAGRAPHEMAILTEXT_NL  = (select PARAGRAPHEMAILTEXT_NL from lams.paragraph@LAMS_GAMMA.ING.BE m where a.PARAGRAPHID=m.PARAGRAPHID),
--PARAGRAPHEMAILTEXT_DE  = (select PARAGRAPHEMAILTEXT_DE from lams.paragraph@LAMS_GAMMA.ING.BE m where a.PARAGRAPHID=m.PARAGRAPHID)


ALTER TABLE SCHEMA.TABLE_IN_TEST  ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA; --database level

******************************ONLINE: REDO LOG
 
ALTER DATABASE ADD LOGFILE ('<log_member_path_and_name>', '<log_member_path_and_name>')SIZE <integer> <M>;
ALTER DATABASE ADD LOGFILE('/APPL/ORACLE/AAINFA/redo_cdc/log1c.rdo', '/APPL/ORACLE/AAINFA/redo_cdc/log2c.rdo') SIZE 500K;
***Adding a redo log file group and specifying the group number

ALTER DATABASE ADD LOGFILE GROUP <group_number> ('/APPL/ORACLE/AAINFA/redo_cdc/log1c.rdo') SIZE <integer> <M>;
ALTER DATABASE ADD LOGFILE GROUP 4 ('/APPL/ORACLE/AAINFA/redo_cdc/') SIZE 100M;
**********************************************
add supplemental loging:
ALTER TABLE SCHEMA.TABLE_IN_TEST  ADD SUPPLEMENTAL LOG DATA (ALL) COLUMNS;
ALTER DATABASE ADD SUPPLEMENTAL LOG DATA; --database level
Create database link  using'(DESCRIPTION== (ADDRESS_LIST = (ADDRESS = (COMMUNITY = tcp.world) (PROTOCOL = TCP) (Host = SBEPAFARA.SRV.BE.EUROPE.INTRANET) (Port = 1530)) (ADDRESS = (COMMUNITY = tcp.world) (PROTOCOL = TCP) (Host = SBEPAFARA.SRV.BE.EUROPE.INTRANET) (Port = 1531))) (CONNECT_DATA = (SID = AGFARA)))'

