...



Here is a support note on stripe size settings:

Article-ID:         <Note:106991.1>
Folder:             server.DBA.Storage
Topic:              Draft Articles
Title:              Understanding striping mechanism
Document-Type:      BULLETIN
Impact:             LOW
Skill-Level:        NOVICE
Server-Version:     08.01.0X
Updated-Date:       28-APR-2000 19:44:38
References:         
Shared-Refs:        
Attachments:        NONE
Content-Type:       TEXT/PLAIN
Keywords:           SIZE; STRIPE; STRIPING; 
Products:           5; 
Platforms:          UNIX;  

*************************************************************
This article is being delivered in Draft form and may contain
errors.  Please use the MetaLink "Feedback" button to advise
Oracle of any issues related to this article.
*************************************************************

PURPOSE
-------

With this note you can learn some news about Striping Disks 
mechanism by Operating System Software.

 
SCOPE & APPLICATION
-------------------

To get better performances in great systems and in multi-user 
environments.


Understanding striping mechanism
---------------------------------
 
Striping divides a large table's data into small portions and stores
these portions in separate datafiles on separate disks. This permits 
multiple processes to access different portions of the table 
concurrently without disk contention. 
Striping can either be performed manually, through careful data file 
allocation to tablespaces, or through operating system striping 
utilities. 

In this note, we treat some news about Striping Disks mechanism by
Operating System Software. 
This approach usually performs better than manual striping, specially 
in not small systems and in multi-user environments.
 
With striping software, the concern is choosing the right stripe
size (it's often needed using a large stripe size of at least 64KB 
with OS striping when possible). 
This depends on the Oracle block size and disk access method.
In particular, the outstanding Oracle parameter is constituted by the
I/O size, which is given by 
DB_BLOCK_SIZE * DB_FILE_MULTIBLOCK_READ_COUNT.
The values of these two parameters are fixed in init.ora file:
DB_BLOCK_SIZE specifies the size in bytes of Oracle database blocks
and its default value is operating-system dependent;
DB_FILE_MULTIBLOCK_READ_COUNT specifies the maximum number of blocks
read in one I/O operation during a sequential scan and its default 
value is 8.
The maximum I/O size is platform-specific (for example, in a range of 
64KB to 1MB). 

Stripe size must be at least as large as the I/O size. 
Having a large value of stripe size it allows the system to perform 
more sequential operations on each disk, since it decreases the 
number of seeks on disk, but it reduces the I/O parallelism so fewer 
disks are simultaneously active.

However, if you have problems, it's preferible increasing the I/O size
of scan operations (going, for example, from 64KB to 128KB), instead of
changing the stripe size. 
A good trade-off is to make stripe size larger than I/O size by a 
factor of 2 or 4.

Striping supports multiple users running sequentially as well as single 
users running in parallel, but it's particularly useful in optimizing 
random access to tables with many rows.
In fact, for operations such as full table scan, it permits to reach 
the maximum I/O throughput for your platform, because it increases  
the number of disk seeks, but in the same time it consents to have a 
large I/O size.
Also, for operations such as a nested loop join or parallel index 
range scan, operating system striping enables you to avoid hot spots: 
I/O is more evenly distributed across the disks. 


==================
@Dim Pan: To check which kind of version of RAID looks more reliable, simply try the following SQL-Statement (tested on 10g2) 
RAID10 is "striped mirrors", e.g. (1=2)+(3=4).
RAID0+1 is "mirrored stripes", e.g. (1+2)=(3+4).
---
WITH t AS (SELECT 'ok' status
             FROM dual
            UNION
           SELECT 'x'
             FROM dual)
SELECT t1.status st_disk1
     , t2.status st_disk2
     , t3.status st_disk3
     , t4.status st_disk4
     , CASE WHEN (t1.status = 'ok' 
              AND t2.status = 'ok')
              OR (t3.status = 'ok'
              AND t4.status = 'ok')
            THEN
              'working'
            ELSE
              'broken'
            END st_raid01  
     , CASE WHEN (t1.status = 'ok' 
               OR t2.status = 'ok')
             AND (t3.status = 'ok'
               OR t4.status = 'ok')
            THEN
              'working'
            ELSE
              'broken'
            END st_raid10  
  FROM t t1
     , t t2
     , t t3
     , t t4
;           